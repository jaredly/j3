{"map":{"0":{"type":"rich-text","contents":[{"id":"8fd26af0-7082-4132-96f0-eb9bd9a651aa","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Bootstrap (js) parser + evaluator","styles":{}}],"children":[]}],"loc":0},"2":{"type":"rich-text","contents":[{"id":"68285dbb-f6ad-428e-a83c-89f93b2af3cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Because we're using a structured editor for our language, the job of parsing is quite a bit simpler; we just need to turn the CST into the AST, instead of messing around with tokenizing, counting parentheses, etc.","styles":{}}],"children":[]}],"loc":2},"8":{"type":"raw-code","lang":"javascript","raw":"({type: 'fns', prelude,\n  compile, compile_stmt,\n  parse_stmt: parseStmt, parse_expr: parse,\n  names,\n  externals_stmt: externals,\n  externals_expr: e => externals_expr(e, []),\n  fromNode: x => x,\n  toNode: x => x})","loc":8},"17":{"type":"blank","loc":17},"21":{"type":"raw-code","lang":"javascript","raw":"evaluate = (node, scope) => {\n  switch (node.type) {\n    case 'eprim':\n      return node[0][0]\n    case 'estr':\n      return unescapeSlashes(node[0]) + unwrapList(node[1]).map(({0: exp, 1: suf}) => evaluate(exp, scope) + unescapeSlashes(suf)).join('')\n    case 'evar':\n      var name = sanitize(node[0])\n      if (!Object.hasOwn(scope, name)) {\n        throw new Error(`Unknown vbl: ${name}. ${Object.keys(scope).join(', ')}`)\n      }\n      return scope[name]\n    case 'elambda':\n      return v => evaluate(node[1], {...scope, [sanitize(node[0])]: v})\n    case 'eapp':\n      return evaluate(node[0], scope)(evaluate(node[1], scope))\n    case 'elet':\n      const init = evaluate(node[1], scope)\n      return evaluate(node[2], {...scope, [sanitize(node[0])]: init})\n    case 'ematch':\n      const target = evaluate(node[0], scope)\n      for (let {0: pat, 1: body} of unwrapList(node[1])) {\n        const got = evalPat(pat, target)\n        if (got) {\n          return evaluate(body, {...scope, ...got})\n        }\n      }\n      throw new Error(`match failed (${node[2]}): ${JSON.stringify(target)}`)\n    case 'equot':\n      return node[0]\n  }\n  throw new Error(`cant evaluatoe ${node.type}`)\n}","loc":21},"23":{"type":"raw-code","lang":"javascript","raw":"c = {\n  prim: (prim, loc=-1) => ({type: 'eprim', 0: prim, 1: loc}),\n  int: (v, loc=-1) => ({type: 'pint', 0: v, 1: loc}),\n  bool: (v, loc=-1) => ({type: 'pbool', 0: v, 1: loc}),\n  evar: (text, loc=-1) => ({type: 'evar', 0: text, 1: loc}),\n  app: (target, arg, loc=-1) => ({type: 'eapp', 0: target, 1: arg, 2: loc}),\n  nil: l => c.evar('nil', l),\n  cons: (a, b, l) => c.app(c.app(c.evar('cons', l), a, l), b, l),\n  list: (values, l) => {\n    let v = c.nil(l)\n    for (let i=values.length-1;i>=0;i--) {\n      v = c.cons(values[i], v, l)\n    }\n    return v\n  },\n  \n}","loc":23},"25":{"type":"raw-code","lang":"javascript","raw":"// turn a javascript array into a linked list with `cons` and `nil`.\nlist = (values) => {\n  let v = nil\n  for (let i = values.length - 1; i >= 0; i--) {\n    v = cons(values[i], v)\n  }\n  return v\n}","loc":25},"27":{"type":"raw-code","lang":"javascript","raw":"cons = (a, b) => ({type: 'cons', 0: a, 1: b})","loc":27},"29":{"type":"raw-code","lang":"javascript","raw":"nil = {type: 'nil'}","loc":29},"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured editor.\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33},"35":{"type":"rich-text","contents":[{"id":"d75f4bc9-5f31-4967-b242-4c02865ab461","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Tree-Walking Evaluator","styles":{}}],"children":[]}],"loc":35},"42":{"type":"raw-code","lang":"javascript","raw":"// Expects a node of type 'identifier' and if it's an int or true/false, returns\n// the appropriate `prim`\nparsePrim = node => {\n  const v = +node.text\n  if (v + '' === node.text && Math.floor(v) === v) {\n    return c.prim(c.int(v, node.loc), node.loc)\n  }\n  if (node.text === 'true' || node.text === 'false') {\n    return c.prim(c.bool(node.text === 'true', node.loc), node.loc)\n  }\n  return null\n}","loc":42},"57":{"type":"raw-code","lang":"javascript","raw":"pair = (a, b) => ({type: ',', 0: a, 1: b})","loc":57},"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: list([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: list([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch',\n            0: parse(target),\n            1: list(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))),\n            2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68},"70":{"type":"raw-code","lang":"javascript","raw":"foldr = (init, items, f) => items.length === 0 ? init : f(foldr(init, items.slice(1), f), items[0])","loc":70},"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76},"78":{"type":"list","values":[80,81,82],"loc":78},"80":{"type":"identifier","text":",","loc":80},"81":{"type":"raw-code","lang":"javascript","raw":"v => valueToString(parse(v))","loc":81},"82":{"type":"array","values":[83,116,1202,1173,1165,1189,127,152,170,191,784],"loc":82},"83":{"type":"list","values":[84,88,1188],"loc":83},"84":{"type":"identifier","text":",","loc":84},"86":{"type":"blank","loc":86},"87":{"type":"identifier","text":"@","loc":87},"88":{"type":"list","values":[87,89],"loc":88},"89":{"type":"identifier","text":"1","loc":89},"98":{"type":"raw-code","lang":"javascript","raw":"// unwrap a list into a javascript array\nunwrapList = value => value.type === 'nil' ? [] : [value[0], ...unwrapList(value[1])]","loc":98},"109":{"type":"raw-code","lang":"javascript","raw":"unwrapList(list([1,2,3]))","loc":109},"111":{"type":"raw-code","lang":"javascript","raw":"// turn a runtime value into a nice-to-read string. Roughly corresponds to `show` from Haskell\n// or `repr` from python\nvalueToString = (v) => {\n    if (typeof v === 'object' && v && 'type' in v) {\n        if (v.type === 'cons' || v.type === 'nil') {\n            const un = unwrapList(v);\n            return '[' + un.map(valueToString).join(' ') + ']';\n        }\n\n        let args = [];\n        for (let i = 0; i in v; i++) {\n            args.push(v[i]);\n        }\n        return `(${v.type}${args\n            .map((arg) => ' ' + valueToString(arg))\n            .join('')})`;\n    }\n    if (typeof v === 'string') {\n        if (v.includes('\"') && !v.includes(\"'\")) {\n            return (\n                \"'\" + JSON.stringify(v).slice(1, -1).replace(/\\\\\"/g, '\"') + \"'\"\n            );\n        }\n        return JSON.stringify(v);\n    }\n    if (typeof v === 'function') {\n        return '<function>';\n    }\n\n    return '' + v;\n};\n","loc":111},"116":{"type":"list","values":[117,1163,1172],"loc":116},"117":{"type":"identifier","text":",","loc":117},"118":{"type":"array","values":[],"loc":118},"119":{"type":"blank","loc":119},"127":{"type":"list","values":[128,129,1183],"loc":127},"128":{"type":"identifier","text":",","loc":128},"129":{"type":"list","values":[131,132,133],"loc":129},"130":{"type":"blank","loc":130},"131":{"type":"identifier","text":"fn","loc":131},"132":{"type":"array","values":[136],"loc":132},"133":{"type":"identifier","text":"1","loc":133},"136":{"type":"identifier","text":"a","loc":136},"149":{"type":"raw-code","lang":"javascript","raw":"// This will be useful for the `let` and `match` forms, where we expect a list of pairs of nodes.\nmakePairs = array => {\n  const res = [];\n  for (let i = 0; i < array.length - 1; i += 2) {\n    res.push([array[i], array[i + 1]]);\n  }\n  return res\n}","loc":149},"152":{"type":"list","values":[153,154,1184],"loc":152},"153":{"type":"identifier","text":",","loc":153},"154":{"type":"list","values":[156,157],"loc":154},"155":{"type":"blank","loc":155},"156":{"type":"identifier","text":"@","loc":156},"157":{"type":"list","values":[160,161,162,163,164,166],"loc":157},"159":{"type":"blank","loc":159},"160":{"type":"identifier","text":"match","loc":160},"161":{"type":"identifier","text":"x","loc":161},"162":{"type":"identifier","text":"1","loc":162},"163":{"type":"identifier","text":"2","loc":163},"164":{"type":"string","first":165,"templates":[],"loc":164},"165":{"type":"stringText","loc":165,"text":"hi"},"166":{"type":"identifier","text":"1","loc":166},"170":{"type":"list","values":[171,172,1185],"loc":170},"171":{"type":"identifier","text":",","loc":171},"172":{"type":"list","values":[174,175],"loc":172},"173":{"type":"blank","loc":173},"174":{"type":"identifier","text":"@","loc":174},"175":{"type":"list","values":[178,179,186],"loc":175},"177":{"type":"blank","loc":177},"178":{"type":"identifier","text":"let","loc":178},"179":{"type":"array","values":[180,185],"loc":179},"180":{"type":"list","values":[181,182,184],"loc":180},"181":{"type":"identifier","text":",","loc":181},"182":{"type":"identifier","text":"a","loc":182},"184":{"type":"identifier","text":"b","loc":184},"185":{"type":"identifier","text":"c","loc":185},"186":{"type":"identifier","text":"d","loc":186},"188":{"type":"raw-code","lang":"javascript","raw":"p = {\n  prim: (v, loc=-1) => ({type: 'pprim', 0: v, 1: loc}),\n  bool: (v, loc=-1) => ({type: 'pbool', 0: v, 1: loc}),\n  int: (v, loc=-1) => ({type: 'pint', 0: v, 1: loc}),\n  any: loc => ({type: 'pany', 0: loc}),\n  con: (name, args, loc) => ({type: 'pcon', 0: name, 1: list(args), 2: loc}),\n  cons: (one, two, loc) => p.con('cons', [one, two], loc),\n  nil: loc => p.con('nil', [], loc),\n}","loc":188},"191":{"type":"list","values":[192,193,1186],"loc":191},"192":{"type":"identifier","text":",","loc":192},"193":{"type":"list","values":[195,196],"loc":193},"194":{"type":"blank","loc":194},"195":{"type":"identifier","text":"@","loc":195},"196":{"type":"list","values":[200,201,209],"loc":196},"198":{"type":"blank","loc":198},"200":{"type":"identifier","text":"let","loc":200},"201":{"type":"array","values":[202,208],"loc":201},"202":{"type":"array","values":[203,207],"loc":202},"203":{"type":"identifier","text":"a","loc":203},"204":{"type":"identifier","text":"b","loc":204},"207":{"type":"spread","contents":204,"loc":207},"208":{"type":"identifier","text":"c","loc":208},"209":{"type":"identifier","text":"d","loc":209},"211":{"type":"rich-text","contents":[{"id":"b188e96a-7452-4d88-8430-9cf830c2407c","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Parser","styles":{}}],"children":[]}],"loc":211},"213":{"type":"rich-text","contents":[{"id":"8e76a41f-02ae-4fa5-beb2-1c769056e297","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Prelude","styles":{}}],"children":[]},{"id":"eee0519b-267f-4dba-b79e-d5c8d1cac4ac","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some basic handy functions","styles":{}}],"children":[]}],"loc":213},"215":{"type":"rich-text","contents":[{"id":"ad2112fc-475c-4792-a999-68dc69e2495b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Expressions","styles":{}}],"children":[]}],"loc":215},"217":{"type":"rich-text","contents":[{"id":"93144679-d97b-45e4-af01-c151bc706b2e","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Patterns","styles":{}}],"children":[]}],"loc":217},"219":{"type":"rich-text","contents":[{"id":"9a25177e-d6f3-4440-9188-01447ef87df0","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Statements","styles":{}}],"children":[]}],"loc":219},"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (values.length && values[0].type === 'identifier') {\n        const f = stmtForms[values[0].text];\n        if (f) {\n          const res = f(node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221},"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: values[0].text, 1: list(values.slice(1).map(parseType)), 2: values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: list(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225},"229":{"type":"list","values":[231,232,233],"loc":229},"231":{"type":"identifier","text":",","loc":231},"232":{"type":"raw-code","lang":"javascript","raw":"v => valueToString(parseStmt(v))","loc":232},"233":{"type":"array","values":[234,240,1006,256],"loc":233},"234":{"type":"list","values":[235,236,1289],"loc":234},"235":{"type":"identifier","text":",","loc":235},"236":{"type":"list","values":[237,238],"loc":236},"237":{"type":"identifier","text":"@","loc":237},"238":{"type":"identifier","text":"1","loc":238},"239":{"type":"blank","loc":239},"240":{"type":"list","values":[241,242,1290],"loc":240},"241":{"type":"identifier","text":",","loc":241},"242":{"type":"list","values":[244,245],"loc":242},"243":{"type":"blank","loc":243},"244":{"type":"identifier","text":"@","loc":244},"245":{"type":"list","values":[252,253,254],"loc":245},"252":{"type":"identifier","text":"def","loc":252},"253":{"type":"identifier","text":"hi","loc":253},"254":{"type":"identifier","text":"10","loc":254},"256":{"type":"list","values":[257,258,1291],"loc":256},"257":{"type":"identifier","text":",","loc":257},"258":{"type":"list","values":[260,261],"loc":258},"259":{"type":"blank","loc":259},"260":{"type":"identifier","text":"@","loc":260},"261":{"type":"list","values":[264,265,266,270],"loc":261},"263":{"type":"blank","loc":263},"264":{"type":"identifier","text":"defn","loc":264},"265":{"type":"identifier","text":"lol","loc":265},"266":{"type":"array","values":[268,269],"loc":266},"268":{"type":"identifier","text":"a","loc":268},"269":{"type":"identifier","text":"b","loc":269},"270":{"type":"list","values":[271,272,273],"loc":270},"271":{"type":"identifier","text":"+","loc":271},"272":{"type":"identifier","text":"a","loc":272},"273":{"type":"identifier","text":"b","loc":273},"275":{"type":"raw-code","lang":"javascript","raw":"run = v => {\n  const res = evaluate(parse(v), {'$co': a => b => pair(a,b)})\n  if (typeof res === 'number' || typeof res === 'string') return res\n  return res\n}","loc":275},"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === node[0]\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapList(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286},"335":{"type":"raw-code","lang":"javascript","raw":"evalStmts = stmts => {\n  if (stmts.type !== 'array') throw new Error('need array')\n  const env = {'$co': a => b => pair(a, b)}\n  let res\n  filterBlanks(stmts.values).forEach(stmt => {\n    res = evaluateStmt(parseStmt(stmt), env)\n  });\n  return valueToString(res)\n}\n","loc":335},"369":{"type":"list","values":[371,372,373],"loc":369},"371":{"type":"identifier","text":",","loc":371},"372":{"type":"raw-code","lang":"javascript","raw":"run","loc":372},"373":{"type":"array","values":[374,388,407,539,558,582],"loc":373},"374":{"type":"list","values":[375,376,387],"loc":374},"375":{"type":"identifier","text":",","loc":375},"376":{"type":"list","values":[377,378],"loc":376},"377":{"type":"identifier","text":"@","loc":377},"378":{"type":"list","values":[381,386],"loc":378},"381":{"type":"list","values":[382,383,385],"loc":381},"382":{"type":"identifier","text":"fn","loc":382},"383":{"type":"array","values":[384],"loc":383},"384":{"type":"identifier","text":"x","loc":384},"385":{"type":"identifier","text":"1","loc":385},"386":{"type":"identifier","text":"0","loc":386},"387":{"type":"identifier","text":"1","loc":387},"388":{"type":"list","values":[389,395,391],"loc":388},"389":{"type":"identifier","text":",","loc":389},"390":{"type":"list","values":[392,393,394],"loc":390},"391":{"type":"identifier","text":"1","loc":391},"392":{"type":"identifier","text":",","loc":392},"393":{"type":"identifier","text":"1","loc":393},"394":{"type":"identifier","text":"2","loc":394},"395":{"type":"list","values":[396,397],"loc":395},"396":{"type":"identifier","text":"@","loc":396},"397":{"type":"list","values":[398,400,406],"loc":397},"398":{"type":"identifier","text":"let","loc":398},"399":{"type":"blank","loc":399},"400":{"type":"array","values":[402,390],"loc":400},"402":{"type":"list","values":[403,404,405],"loc":402},"403":{"type":"identifier","text":",","loc":403},"404":{"type":"identifier","text":"x","loc":404},"405":{"type":"identifier","text":"_","loc":405},"406":{"type":"identifier","text":"x","loc":406},"407":{"type":"list","values":[408,409,1298],"loc":407},"408":{"type":"identifier","text":",","loc":408},"409":{"type":"list","values":[412,413],"loc":409},"410":{"type":"blank","loc":410},"412":{"type":"identifier","text":"@","loc":412},"413":{"type":"list","values":[414,415,416,417,418,419],"loc":413},"414":{"type":"identifier","text":"match","loc":414},"415":{"type":"identifier","text":"3","loc":415},"416":{"type":"identifier","text":"1","loc":416},"417":{"type":"identifier","text":"2","loc":417},"418":{"type":"identifier","text":"3","loc":418},"419":{"type":"identifier","text":"10","loc":419},"420":{"type":"raw-code","lang":"javascript","raw":"evaluateStmt = (node, env) => {\n  switch (node.type) {\n    case 'sexpr': return evaluate(node[0], env)\n    case 'sdef':\n      const value = evaluate(node[1], env)\n      env[sanitize(node[0])] = value\n      return value\n    case 'sdeftype':\n      const res = {}\n      unwrapList(node[1]).forEach(({0: name, 1: args}) => {\n        res[sanitize(name)] = env[sanitize(name)] = constrFn(name, args)\n      })\n      return res\n  }\n}\n","loc":420},"422":{"type":"raw-code","lang":"javascript","raw":"constrFn = (name, args) => {\n  const next = (args) => {\n    if (args.type === 'nil') return values => ({type: name, ...values})\n    return values => arg => next(args[1])([...values, arg])\n  }\n  return next(args)([])\n}","loc":422},"455":{"type":"list","values":[457,458,459],"loc":455},"457":{"type":"identifier","text":",","loc":457},"458":{"type":"raw-code","lang":"javascript","raw":"evalStmts","loc":458},"459":{"type":"array","values":[460,468,478,495,1333,520,756],"loc":459},"460":{"type":"list","values":[461,462,1309],"loc":460},"461":{"type":"identifier","text":",","loc":461},"462":{"type":"array","values":[466],"loc":462},"463":{"type":"blank","loc":463},"466":{"type":"identifier","text":"0","loc":466},"468":{"type":"list","values":[469,470,1308],"loc":468},"469":{"type":"identifier","text":",","loc":469},"470":{"type":"array","values":[472,476],"loc":470},"471":{"type":"blank","loc":471},"472":{"type":"list","values":[473,474,475],"loc":472},"473":{"type":"identifier","text":"def","loc":473},"474":{"type":"identifier","text":"n","loc":474},"475":{"type":"identifier","text":"10","loc":475},"476":{"type":"identifier","text":"n","loc":476},"478":{"type":"list","values":[479,480,1304],"loc":478},"479":{"type":"identifier","text":",","loc":479},"480":{"type":"array","values":[482,491],"loc":480},"481":{"type":"blank","loc":481},"482":{"type":"list","values":[483,484,485,487],"loc":482},"483":{"type":"identifier","text":"defn","loc":483},"484":{"type":"identifier","text":"hi","loc":484},"485":{"type":"array","values":[486],"loc":485},"486":{"type":"identifier","text":"x","loc":486},"487":{"type":"list","values":[488,489,490],"loc":487},"488":{"type":"identifier","text":",","loc":488},"489":{"type":"identifier","text":"x","loc":489},"490":{"type":"identifier","text":"2","loc":490},"491":{"type":"list","values":[492,493],"loc":491},"492":{"type":"identifier","text":"hi","loc":492},"493":{"type":"identifier","text":"5","loc":493},"495":{"type":"list","values":[496,497,1305],"loc":495},"496":{"type":"identifier","text":",","loc":496},"497":{"type":"array","values":[499,516],"loc":497},"498":{"type":"blank","loc":498},"499":{"type":"list","values":[500,508,511,514],"loc":499},"500":{"type":"identifier","text":"deftype","loc":500},"506":{"type":"blank","loc":506},"508":{"type":"list","values":[509,510],"loc":508},"509":{"type":"identifier","text":"option","loc":509},"510":{"type":"identifier","text":"a","loc":510},"511":{"type":"list","values":[512,513],"loc":511},"512":{"type":"identifier","text":"some","loc":512},"513":{"type":"identifier","text":"a","loc":513},"514":{"type":"list","values":[515],"loc":514},"515":{"type":"identifier","text":"none","loc":515},"516":{"type":"list","values":[517,518],"loc":516},"517":{"type":"identifier","text":"some","loc":517},"518":{"type":"identifier","text":"10","loc":518},"520":{"type":"list","values":[521,522,1306],"loc":520},"521":{"type":"identifier","text":",","loc":521},"522":{"type":"array","values":[524,532],"loc":522},"523":{"type":"blank","loc":523},"524":{"type":"list","values":[525,526,527],"loc":524},"525":{"type":"identifier","text":"deftype","loc":525},"526":{"type":"identifier","text":"lots","loc":526},"527":{"type":"list","values":[528,529,530,531],"loc":527},"528":{"type":"identifier","text":"lol","loc":528},"529":{"type":"identifier","text":"a","loc":529},"530":{"type":"identifier","text":"b","loc":530},"531":{"type":"identifier","text":"c","loc":531},"532":{"type":"list","values":[533,534,535,536],"loc":532},"533":{"type":"identifier","text":"lol","loc":533},"534":{"type":"identifier","text":"1","loc":534},"535":{"type":"identifier","text":"true","loc":535},"536":{"type":"string","first":537,"templates":[],"loc":536},"537":{"type":"stringText","loc":537,"text":"hi"},"539":{"type":"list","values":[540,541,542],"loc":539},"540":{"type":"identifier","text":",","loc":540},"541":{"type":"list","values":[544,545],"loc":541},"542":{"type":"string","first":550,"templates":[],"loc":542},"543":{"type":"stringText","loc":543,"text":""},"544":{"type":"identifier","text":"@","loc":544},"545":{"type":"string","first":546,"templates":[{"expr":548,"suffix":549}],"loc":545},"546":{"type":"stringText","loc":546,"text":"hi "},"548":{"type":"identifier","text":"1","loc":548},"549":{"type":"stringText","text":".","loc":549},"550":{"type":"stringText","loc":550,"text":"hi 1."},"553":{"type":"stringText","loc":553,"text":""},"558":{"type":"list","values":[559,563,561],"loc":558},"559":{"type":"identifier","text":",","loc":559},"560":{"type":"string","first":562,"templates":[],"loc":560},"561":{"type":"string","first":565,"templates":[],"loc":561},"562":{"type":"stringText","loc":562,"text":"hi"},"563":{"type":"list","values":[564,560],"loc":563},"564":{"type":"identifier","text":"@","loc":564},"565":{"type":"stringText","loc":565,"text":"hi"},"570":{"type":"raw-code","lang":"javascript","raw":"makePrelude = obj => Object.entries(obj).reduce((obj, [k, v]) => (obj[k] = typeof v === 'function' ? '' + v : typeof v === 'string' ? v : JSON.stringify(v), obj), {})","loc":570},"572":{"type":"raw-code","lang":"javascript","raw":"prelude = makePrelude({evaluate,evaluateStmt,unwrapList,constrFn,sanitize,sanMap,evalPat,kwds,unescapeSlashes}) ","loc":572},"576":{"type":"blank","loc":576},"582":{"type":"list","values":[583,584,1297],"loc":582},"583":{"type":"identifier","text":",","loc":583},"584":{"type":"list","values":[587,588],"loc":584},"585":{"type":"blank","loc":585},"587":{"type":"identifier","text":"@","loc":587},"588":{"type":"list","values":[589,590,591],"loc":588},"589":{"type":"identifier","text":",","loc":589},"590":{"type":"identifier","text":"1","loc":590},"591":{"type":"identifier","text":"2","loc":591},"593":{"type":"raw-code","lang":"javascript","raw":"compile = ast => _meta => `$env.evaluate(${JSON.stringify(ast)}, $env)`","loc":593},"595":{"type":"raw-code","lang":"javascript","raw":"compile_stmt = ast => _meta => `${ast.type === 'sdef' ? `const ${sanitize(ast[0])} = ` : ast.type === 'sdeftype' ? `const {${\n  unwrapList(ast[1]).map(c => `\"${c[0]}\": ${sanitize(c[0])}`)\n}} = ` : ''}$env.evaluateStmt(${JSON.stringify(ast)}, $env)`","loc":595},"597":{"type":"rich-text","contents":[{"id":"e8800480-68f3-4e7e-99c1-03c3b168698b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Analysis","styles":{}}],"children":[]}],"loc":597},"599":{"type":"raw-code","lang":"javascript","raw":"externals = stmt => {\n  switch (stmt.type) {\n    case 'sexpr': return externals_expr(stmt[0], [])\n    case 'sdef': return externals_expr(stmt[1], [stmt[0]])\n    case 'sdeftype': return []\n  }\n  return []\n}","loc":599},"601":{"type":"list","values":[603,615,616],"loc":601},"603":{"type":"identifier","text":",","loc":603},"606":{"type":"identifier","text":",","loc":606},"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v =>(externals(parseStmt(v)))","loc":607},"611":{"type":"raw-code","lang":"javascript","raw":"externals_expr = (expr, locals) => {\n  switch (expr.type) {\n    case 'evar': return locals.includes(expr[0]) ? [] : [{name: expr[0], kind: 'value', loc: expr[1]}]\n    case 'eapp': return externals_expr(expr[0], locals).concat(externals_expr(expr[1], locals))\n    case 'elambda': return externals_expr(expr[1], locals.concat(expr[0]))\n    case 'eprim': return []\n    case 'estr': return unwrapList(expr[1]).flatMap(v => externals_expr(v[0], locals))\n    case 'elet': return externals_expr(expr[1], locals).concat(\n      externals_expr(expr[2], locals.concat(expr[0])))\n    case 'ematch':\n      return externals_expr(expr[0], locals).concat(\n        unwrapList(expr[1]).flatMap(kase => externals_expr(kase[1], locals.concat(pat_names(kase[0])))))\n  }\n  return []\n}","loc":611},"613":{"type":"raw-code","lang":"javascript","raw":"pat_names = pat => {\n  switch (pat.type) {\n    case 'pvar': return [pat[0]]\n    case 'pany': return []\n    case 'pprim': return []\n    case 'pcon':\n      return unwrapList(pat[1]).flatMap(pat_names)\n  }\n  return []\n}\n","loc":613},"615":{"type":"raw-code","lang":"javascript","raw":"testExt","loc":615},"616":{"type":"array","values":[617,631,646,656,673,814],"loc":616},"617":{"type":"list","values":[606,619,1049],"loc":617},"618":{"type":"identifier","text":"@","loc":618},"619":{"type":"list","values":[618,620],"loc":619},"620":{"type":"identifier","text":"lol","loc":620},"621":{"type":"blank","loc":621},"630":{"type":"stringText","loc":630,"text":"[[\\\"lol\\\", (value), 620]]"},"631":{"type":"list","values":[632,633,1051],"loc":631},"632":{"type":"identifier","text":",","loc":632},"633":{"type":"list","values":[635,636],"loc":633},"634":{"type":"blank","loc":634},"635":{"type":"identifier","text":"@","loc":635},"636":{"type":"list","values":[637,638,640],"loc":636},"637":{"type":"identifier","text":"fn","loc":637},"638":{"type":"array","values":[644],"loc":638},"639":{"type":"identifier","text":",","loc":639},"640":{"type":"list","values":[641,642],"loc":640},"641":{"type":"identifier","text":"+","loc":641},"642":{"type":"identifier","text":"x","loc":642},"644":{"type":"list","values":[639,645],"loc":644},"645":{"type":"identifier","text":"x","loc":645},"646":{"type":"list","values":[647,648,1055],"loc":646},"647":{"type":"identifier","text":",","loc":647},"648":{"type":"list","values":[650,651],"loc":648},"649":{"type":"blank","loc":649},"650":{"type":"identifier","text":"@","loc":650},"651":{"type":"string","first":652,"templates":[{"expr":653,"suffix":654}],"loc":651},"652":{"type":"stringText","loc":652,"text":"hi "},"653":{"type":"identifier","text":"x","loc":653},"654":{"type":"stringText","text":"","loc":654},"656":{"type":"list","values":[657,658,1054],"loc":656},"657":{"type":"identifier","text":",","loc":657},"658":{"type":"list","values":[660,661],"loc":658},"659":{"type":"blank","loc":659},"660":{"type":"identifier","text":"@","loc":660},"661":{"type":"list","values":[662,663,664,670],"loc":661},"662":{"type":"identifier","text":"match","loc":662},"663":{"type":"identifier","text":"m","loc":663},"664":{"type":"list","values":[666,668,669],"loc":664},"665":{"type":"identifier","text":"+","loc":665},"666":{"type":"identifier","text":",","loc":666},"668":{"type":"identifier","text":"a","loc":668},"669":{"type":"identifier","text":"b","loc":669},"670":{"type":"list","values":[665,671],"loc":670},"671":{"type":"identifier","text":"a","loc":671},"673":{"type":"list","values":[674,675,1052],"loc":673},"674":{"type":"identifier","text":",","loc":674},"675":{"type":"list","values":[677,678],"loc":675},"676":{"type":"blank","loc":676},"677":{"type":"identifier","text":"@","loc":677},"678":{"type":"list","values":[681,682,685],"loc":678},"680":{"type":"blank","loc":680},"681":{"type":"identifier","text":"let","loc":681},"682":{"type":"array","values":[683,684],"loc":682},"683":{"type":"identifier","text":"x","loc":683},"684":{"type":"identifier","text":"2","loc":684},"685":{"type":"list","values":[686,687],"loc":685},"686":{"type":"identifier","text":"+","loc":686},"687":{"type":"identifier","text":"x","loc":687},"689":{"type":"raw-code","lang":"javascript","raw":"names = stmt => {\n  switch (stmt.type) {\n    case 'sexpr': return []\n    case 'sdef': return [{name: stmt[0], kind: 'value', loc: stmt[2]}]\n    case 'sdeftype': return unwrapList(stmt[1]).map(c => ({name: c[0], kind: 'value', loc: c[2]}))\n  }\n}","loc":689},"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => names(parseStmt(v))","loc":691},"693":{"type":"list","values":[696,697,699],"loc":693},"696":{"type":"identifier","text":",","loc":696},"697":{"type":"raw-code","lang":"javascript","raw":"testNames","loc":697},"699":{"type":"array","values":[700,707,717],"loc":699},"700":{"type":"list","values":[701,702,1047],"loc":700},"701":{"type":"identifier","text":",","loc":701},"702":{"type":"list","values":[703,704],"loc":702},"703":{"type":"identifier","text":"@","loc":703},"704":{"type":"identifier","text":"hi","loc":704},"705":{"type":"blank","loc":705},"707":{"type":"list","values":[708,709,1056],"loc":707},"708":{"type":"identifier","text":",","loc":708},"709":{"type":"list","values":[711,712],"loc":709},"710":{"type":"blank","loc":710},"711":{"type":"identifier","text":"@","loc":711},"712":{"type":"list","values":[713,714,715],"loc":712},"713":{"type":"identifier","text":"def","loc":713},"714":{"type":"identifier","text":"x","loc":714},"715":{"type":"identifier","text":"10","loc":715},"717":{"type":"list","values":[718,719,1057],"loc":717},"718":{"type":"identifier","text":",","loc":718},"719":{"type":"list","values":[721,722],"loc":719},"720":{"type":"blank","loc":720},"721":{"type":"identifier","text":"@","loc":721},"722":{"type":"list","values":[723,724,727,732],"loc":722},"723":{"type":"identifier","text":"deftype","loc":723},"724":{"type":"list","values":[725,726],"loc":724},"725":{"type":"identifier","text":"option","loc":725},"726":{"type":"identifier","text":"x","loc":726},"727":{"type":"list","values":[730,731],"loc":727},"729":{"type":"blank","loc":729},"730":{"type":"identifier","text":"some","loc":730},"731":{"type":"identifier","text":"x","loc":731},"732":{"type":"list","values":[733],"loc":732},"733":{"type":"identifier","text":"none","loc":733},"738":{"type":"raw-code","lang":"javascript","raw":"testCompileStmt = v => compile_stmt(parseStmt(v))()","loc":738},"740":{"type":"list","values":[742,743],"loc":740},"742":{"type":"raw-code","lang":"javascript","raw":"testCompileStmt","loc":742},"743":{"type":"list","values":[744,747,748,750],"loc":743},"744":{"type":"identifier","text":"deftype","loc":744},"747":{"type":"identifier","text":"card","loc":747},"748":{"type":"list","values":[749],"loc":748},"749":{"type":"identifier","text":"red","loc":749},"750":{"type":"list","values":[751],"loc":750},"751":{"type":"identifier","text":"black","loc":751},"754":{"type":"raw-code","lang":"javascript","raw":"// Convert an identifier into a valid js identifier, replacing special characters, and accounting for keywords.\nsanitize =  (raw) => {\n    for (let [key, val] of Object.entries(sanMap)) {\n        raw = raw.replaceAll(key, val);\n    }\n    if (kwds.includes(raw)) return '$' + raw\n    return raw\n}\n","loc":754},"756":{"type":"list","values":[757,758,1307],"loc":756},"757":{"type":"identifier","text":",","loc":757},"758":{"type":"array","values":[760,770],"loc":758},"759":{"type":"blank","loc":759},"760":{"type":"list","values":[761,762,765],"loc":760},"761":{"type":"identifier","text":"deftype","loc":761},"762":{"type":"identifier","text":"a","loc":762},"765":{"type":"list","values":[767,768,769],"loc":765},"767":{"type":"identifier","text":"com,","loc":767},"768":{"type":"identifier","text":"1","loc":768},"769":{"type":"identifier","text":"2","loc":769},"770":{"type":"list","values":[771,772,773],"loc":770},"771":{"type":"identifier","text":"com,","loc":771},"772":{"type":"identifier","text":"1","loc":772},"773":{"type":"identifier","text":"2","loc":773},"775":{"type":"list","values":[1219,1220,1221],"loc":775},"784":{"type":"list","values":[785,786,1187],"loc":784},"785":{"type":"identifier","text":",","loc":785},"786":{"type":"list","values":[788,789],"loc":786},"787":{"type":"blank","loc":787},"788":{"type":"identifier","text":"@","loc":788},"789":{"type":"array","values":[790,794],"loc":789},"790":{"type":"identifier","text":"a","loc":790},"791":{"type":"identifier","text":"b","loc":791},"794":{"type":"spread","contents":791,"loc":794},"803":{"type":"raw-code","lang":"javascript","raw":"fromNode = node => {\n  switch (node.type) {\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return\n    case 'identifier':\n      return {type: 'cst/identifier', 0: node.text, 1: node.loc}\n    case 'spread':\n      const inner = fromNode(node.contents)\n      return inner\n      ? {type: 'cst/spread', 0: inner, 1: node.loc}\n      : {type: 'cst/empty-spread', 0: node.loc}\n    case 'array':\n    case 'record':\n    case 'list':\n      return {type: 'cst/' + node.type, 0: list(node.values.map(fromNode).filter(Boolean)), 1: node.loc}\n    case 'string':\n      return {type: 'cst/string', 0: node.first.text, 1: list(\n        node.templates.map(item => ({\n          type: ',,',\n          0: fromNode(item.expr) ?? {type: 'cst/string', 0: '', 1: nil},\n          1: item.suffix.text,\n          2: item.suffix.loc,\n        }))\n      ), 2: node.loc}\n  }\n}","loc":803},"806":{"type":"raw-code","lang":"javascript","raw":"sanitize('for')","loc":806},"808":{"type":"raw-code","lang":"javascript","raw":"sanMap = {\n    // '$$$$' gets interpreted by replaceAll as '$$', for reasons\n    $: '$$$$',\n    '-': '_',\n    '+': '$pl',\n    '*': '$ti',\n    '=': '$eq',\n    '>': '$gt',\n    '<': '$lt',\n    \"'\": '$qu',\n    '\"': '$dq',\n    ',': '$co',\n    '/': '$sl',\n    ';': '$semi',\n    '@': '$at',\n    '!': '$ex',\n    '|': '$bar',\n    '()': '$unit',\n    '?': '$qe',\n  };\n","loc":808},"810":{"type":"raw-code","lang":"javascript","raw":"kwds = (() => {\n  const kwds =\n    'case new var const let if else return super break while for default';\n  const rx = [];\n  return kwds.split(' ')\n})();\n","loc":810},"814":{"type":"list","values":[815,816,1053],"loc":814},"815":{"type":"identifier","text":",","loc":815},"816":{"type":"list","values":[818,837],"loc":816},"817":{"type":"blank","loc":817},"818":{"type":"identifier","text":"@","loc":818},"819":{"type":"blank","loc":819},"821":{"type":"blank","loc":821},"837":{"loc":837,"type":"list","values":[838,839,840,845]},"838":{"loc":838,"type":"identifier","text":"defn"},"839":{"loc":839,"type":"identifier","text":"pat-loop"},"840":{"loc":840,"type":"array","values":[841,842,843,844]},"841":{"loc":841,"type":"identifier","text":"target"},"842":{"loc":842,"type":"identifier","text":"args"},"843":{"loc":843,"type":"identifier","text":"i"},"844":{"loc":844,"type":"identifier","text":"inner"},"845":{"loc":845,"type":"list","values":[846,847,848,849,850,854]},"846":{"loc":846,"type":"identifier","text":"match"},"847":{"loc":847,"type":"identifier","text":"args"},"848":{"loc":848,"type":"array","values":[]},"849":{"loc":849,"type":"identifier","text":"inner"},"850":{"loc":850,"type":"array","values":[851,852]},"851":{"loc":851,"type":"identifier","text":"arg"},"852":{"loc":852,"type":"spread","contents":853},"853":{"loc":853,"type":"identifier","text":"rest"},"854":{"loc":854,"type":"list","values":[855,856,857,863]},"855":{"loc":855,"type":"identifier","text":"compile-pat"},"856":{"loc":856,"type":"identifier","text":"arg"},"857":{"loc":857,"type":"string","first":858,"templates":[{"expr":859,"suffix":860},{"expr":861,"suffix":862}]},"858":{"loc":858,"type":"stringText","text":""},"859":{"loc":859,"type":"identifier","text":"target"},"860":{"loc":860,"type":"stringText","text":"["},"861":{"loc":861,"type":"identifier","text":"i"},"862":{"loc":862,"type":"stringText","text":"]"},"863":{"loc":863,"type":"list","values":[864,865,866,867,871]},"864":{"loc":864,"type":"identifier","text":"pat-loop"},"865":{"loc":865,"type":"identifier","text":"target"},"866":{"loc":866,"type":"identifier","text":"rest"},"867":{"loc":867,"type":"list","values":[868,869,870]},"868":{"loc":868,"type":"identifier","text":"+"},"869":{"loc":869,"type":"identifier","text":"i"},"870":{"loc":870,"type":"identifier","text":"1"},"871":{"loc":871,"type":"identifier","text":"inner"},"872":{"type":"raw-code","lang":"javascript","raw":"// \"A\\\\nB\" -> \"A\\nB\"\nunescapeSlashes = (n) =>\n    n.replaceAll(/\\\\./g, (m) => {\n        if (m[1] === 'n') {\n            return '\\n';\n        }\n        if (m[1] === 't') {\n            return '\\t';\n        }\n        if (m[1] === 'r') {\n            return '\\r';\n        }\n        return m[1];\n    })","loc":872},"879":{"loc":879,"type":"list","values":[880,881,884,886]},"880":{"loc":880,"type":"identifier","text":"deftype"},"881":{"loc":881,"type":"list","values":[882,883]},"882":{"loc":882,"type":"identifier","text":"list"},"883":{"loc":883,"type":"identifier","text":"a"},"884":{"loc":884,"type":"list","values":[885]},"885":{"loc":885,"type":"identifier","text":"nil"},"886":{"loc":886,"type":"list","values":[887,888,889]},"887":{"loc":887,"type":"identifier","text":"cons"},"888":{"loc":888,"type":"identifier","text":"a"},"889":{"loc":889,"type":"list","values":[890,891]},"890":{"loc":890,"type":"identifier","text":"list"},"891":{"loc":891,"type":"identifier","text":"a"},"893":{"loc":893,"type":"list","values":[894,895,896,899,902,906,910,915]},"894":{"loc":894,"type":"identifier","text":"deftype"},"895":{"loc":895,"type":"identifier","text":"expr"},"896":{"loc":896,"type":"list","values":[897,898]},"897":{"loc":897,"type":"identifier","text":"eprim"},"898":{"loc":898,"type":"identifier","text":"prim"},"899":{"loc":899,"type":"list","values":[900,901]},"900":{"loc":900,"type":"identifier","text":"evar"},"901":{"loc":901,"type":"identifier","text":"string"},"902":{"loc":902,"type":"list","values":[903,904,905]},"903":{"loc":903,"type":"identifier","text":"elambda"},"904":{"loc":904,"type":"identifier","text":"string"},"905":{"loc":905,"type":"identifier","text":"expr"},"906":{"loc":906,"type":"list","values":[907,908,909]},"907":{"loc":907,"type":"identifier","text":"eapp"},"908":{"loc":908,"type":"identifier","text":"expr"},"909":{"loc":909,"type":"identifier","text":"expr"},"910":{"loc":910,"type":"list","values":[911,912,913,914]},"911":{"loc":911,"type":"identifier","text":"elet"},"912":{"loc":912,"type":"identifier","text":"string"},"913":{"loc":913,"type":"identifier","text":"expr"},"914":{"loc":914,"type":"identifier","text":"expr"},"915":{"loc":915,"type":"list","values":[916,917,918]},"916":{"loc":916,"type":"identifier","text":"ematch"},"917":{"loc":917,"type":"identifier","text":"expr"},"918":{"loc":918,"type":"list","values":[919,920]},"919":{"loc":919,"type":"identifier","text":"list"},"920":{"loc":920,"type":"list","values":[921,922,923]},"921":{"loc":921,"type":"identifier","text":","},"922":{"loc":922,"type":"identifier","text":"pat"},"923":{"loc":923,"type":"identifier","text":"expr"},"925":{"loc":925,"type":"list","values":[926,927,928,931]},"926":{"loc":926,"type":"identifier","text":"deftype"},"927":{"loc":927,"type":"identifier","text":"prim"},"928":{"loc":928,"type":"list","values":[929,930]},"929":{"loc":929,"type":"identifier","text":"pint"},"930":{"loc":930,"type":"identifier","text":"int"},"931":{"loc":931,"type":"list","values":[932,933]},"932":{"loc":932,"type":"identifier","text":"pbool"},"933":{"loc":933,"type":"identifier","text":"bool"},"935":{"loc":935,"type":"list","values":[936,937,938,940,943,946,949]},"936":{"loc":936,"type":"identifier","text":"deftype"},"937":{"loc":937,"type":"identifier","text":"pat"},"938":{"loc":938,"type":"list","values":[939]},"939":{"loc":939,"type":"identifier","text":"pany"},"940":{"loc":940,"type":"list","values":[941,942]},"941":{"loc":941,"type":"identifier","text":"pvar"},"942":{"loc":942,"type":"identifier","text":"string"},"943":{"loc":943,"type":"list","values":[944,945]},"944":{"loc":944,"type":"identifier","text":"pprim"},"945":{"loc":945,"type":"identifier","text":"prim"},"946":{"loc":946,"type":"list","values":[947,948]},"947":{"loc":947,"type":"identifier","text":"pstr"},"948":{"loc":948,"type":"identifier","text":"string"},"949":{"loc":949,"type":"list","values":[950,951,952]},"950":{"loc":950,"type":"identifier","text":"pcon"},"951":{"loc":951,"type":"identifier","text":"string"},"952":{"loc":952,"type":"list","values":[953,954]},"953":{"loc":953,"type":"identifier","text":"list"},"954":{"loc":954,"type":"identifier","text":"string"},"956":{"loc":956,"type":"list","values":[957,958,959,962,966]},"957":{"loc":957,"type":"identifier","text":"deftype"},"958":{"loc":958,"type":"identifier","text":"type"},"959":{"loc":959,"type":"list","values":[960,961]},"960":{"loc":960,"type":"identifier","text":"tvar"},"961":{"loc":961,"type":"identifier","text":"int"},"962":{"loc":962,"type":"list","values":[963,964,965]},"963":{"loc":963,"type":"identifier","text":"tapp"},"964":{"loc":964,"type":"identifier","text":"type"},"965":{"loc":965,"type":"identifier","text":"type"},"966":{"loc":966,"type":"list","values":[967,968]},"967":{"loc":967,"type":"identifier","text":"tcon"},"968":{"loc":968,"type":"identifier","text":"string"},"970":{"loc":970,"type":"list","values":[971,972,973,984,988]},"971":{"loc":971,"type":"identifier","text":"deftype"},"972":{"loc":972,"type":"identifier","text":"stmt"},"973":{"loc":973,"type":"list","values":[974,975,976]},"974":{"loc":974,"type":"identifier","text":"sdeftype"},"975":{"loc":975,"type":"identifier","text":"string"},"976":{"loc":976,"type":"list","values":[977,978]},"977":{"loc":977,"type":"identifier","text":"list"},"978":{"loc":978,"type":"list","values":[979,980,981]},"979":{"loc":979,"type":"identifier","text":","},"980":{"loc":980,"type":"identifier","text":"string"},"981":{"loc":981,"type":"list","values":[982,983]},"982":{"loc":982,"type":"identifier","text":"list"},"983":{"loc":983,"type":"identifier","text":"type"},"984":{"loc":984,"type":"list","values":[985,986,987]},"985":{"loc":985,"type":"identifier","text":"sdef"},"986":{"loc":986,"type":"identifier","text":"string"},"987":{"loc":987,"type":"identifier","text":"expr"},"988":{"loc":988,"type":"list","values":[989,990]},"989":{"loc":989,"type":"identifier","text":"sexpr"},"990":{"loc":990,"type":"identifier","text":"expr"},"991":{"type":"comment-node","loc":991,"contents":879},"992":{"type":"comment-node","loc":992,"contents":893},"993":{"type":"comment-node","loc":993,"contents":925},"994":{"type":"comment-node","loc":994,"contents":935},"995":{"type":"comment-node","loc":995,"contents":956},"996":{"type":"comment-node","loc":996,"contents":970},"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 &&\n        values[0].type === 'identifier' &&\n        values[0].text === 'fn' &&\n        values[1].type === 'array') {\n      const body = parseType(values[2])\n      // This 'reduceRight' is how we convert a function type declaration\n      // with potentially many arguments into function types with only\n      // single arguments.\n      // for a fn type (fn [a b c] d)\n      // the inner function will be called with\n      //    [body]                       [arg]\n      // -> d                            c\n      // -> (fn [c] d)                   b\n      // -> (fn [b] (fn [c] d))          a\n      // and returns\n      // -> (fn [a] (fn [b] (fn [d] d)))\n      return values[1].values.reduceRight((body, arg) => (\n        {type: 'tapp',\n         0: {type: 'tapp',\n             0: {type: 'tcon', 0: '->', 1: node.loc},\n             1: parseType(arg), 2: node.loc},\n         1: body,\n         2: node.loc}\n      ), body)\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997},"1006":{"type":"list","values":[1007,1008,1292],"loc":1006},"1007":{"type":"identifier","text":",","loc":1007},"1008":{"type":"list","values":[1010,1011],"loc":1008},"1009":{"type":"blank","loc":1009},"1010":{"type":"identifier","text":"@","loc":1010},"1011":{"type":"list","values":[1012,1013,1016,1019],"loc":1011},"1012":{"type":"identifier","text":"deftype","loc":1012},"1013":{"type":"list","values":[1014,1015],"loc":1013},"1014":{"type":"identifier","text":"option","loc":1014},"1015":{"type":"identifier","text":"a","loc":1015},"1016":{"type":"list","values":[1017,1018],"loc":1016},"1017":{"type":"identifier","text":"some","loc":1017},"1018":{"type":"identifier","text":"a","loc":1018},"1019":{"type":"list","values":[1020],"loc":1019},"1020":{"type":"identifier","text":"none","loc":1020},"1022":{"type":"raw-code","lang":"javascript","raw":"// These are the CST nodes that we want to ignore while parsing.\nfilterBlanks = values => values.filter(n => !['blank', 'comment', 'rich-text', 'comment-node'].includes(n.type))","loc":1022},"1040":{"type":"blank","loc":1040},"1041":{"type":"blank","loc":1041},"1042":{"type":"blank","loc":1042},"1043":{"type":"blank","loc":1043},"1044":{"type":"blank","loc":1044},"1045":{"type":"blank","loc":1045},"1046":{"type":"blank","loc":1046},"1047":{"type":"raw-code","lang":"javascript","loc":1047,"raw":"[]"},"1048":{"type":"blank","loc":1048},"1049":{"type":"raw-code","lang":"javascript","loc":1049,"raw":"[{\"name\":\"lol\",\"kind\":\"value\",\"loc\":620}]"},"1051":{"type":"raw-code","lang":"javascript","loc":1051,"raw":"[{\"name\":\"+\",\"kind\":\"value\",\"loc\":641}]"},"1052":{"type":"raw-code","lang":"javascript","loc":1052,"raw":"[{\"name\":\"+\",\"kind\":\"value\",\"loc\":686}]"},"1053":{"type":"raw-code","lang":"javascript","loc":1053,"raw":"[{\"name\":\"compile-pat\",\"kind\":\"value\",\"loc\":855},{\"name\":\"+\",\"kind\":\"value\",\"loc\":868}]"},"1054":{"type":"raw-code","lang":"javascript","loc":1054,"raw":"[{\"name\":\"m\",\"kind\":\"value\",\"loc\":663},{\"name\":\"+\",\"kind\":\"value\",\"loc\":665}]"},"1055":{"type":"raw-code","lang":"javascript","loc":1055,"raw":"[{\"name\":\"x\",\"kind\":\"value\",\"loc\":653}]"},"1056":{"type":"raw-code","lang":"javascript","loc":1056,"raw":"[{\"name\":\"x\",\"kind\":\"value\",\"loc\":712}]"},"1057":{"type":"raw-code","lang":"javascript","loc":1057,"raw":"[{\"name\":\"some\",\"kind\":\"value\",\"loc\":730},{\"name\":\"none\",\"kind\":\"value\",\"loc\":733}]"},"1058":{"type":"rich-text","contents":[{"id":"ca311a47-d079-401a-9fb9-92d6be75db3e","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Packaging it up as a Compiler for the structured editor","styles":{}}],"children":[]}],"loc":1058},"1062":{"type":"list","values":[140],"loc":1062},"1063":{"type":"blank","loc":1063},"1064":{"type":"list","values":[140],"loc":1064},"1065":{"type":"blank","loc":1065},"1066":{"type":"list","values":[1068,1069,1070],"loc":1066},"1068":{"type":"identifier","text":",","loc":1068},"1069":{"type":"raw-code","lang":"javascript","raw":"n => valueToString(parsePrim(n) ?? \"not a prim\")","loc":1069},"1070":{"type":"array","values":[1071,1098,1082,1089],"loc":1070},"1071":{"type":"list","values":[1072,1079,1432],"loc":1071},"1072":{"type":"identifier","text":",","loc":1072},"1074":{"type":"blank","loc":1074},"1075":{"type":"identifier","text":"@","loc":1075},"1077":{"type":"raw-code","lang":"javascript","raw":"parsePrim({text: '23', loc: 10})","loc":1077},"1079":{"type":"list","values":[1075,1080],"loc":1079},"1080":{"type":"identifier","text":"true","loc":1080},"1081":{"type":"blank","loc":1081},"1082":{"type":"list","values":[1083,1084,1434],"loc":1082},"1083":{"type":"identifier","text":",","loc":1083},"1084":{"type":"list","values":[1086,1087],"loc":1084},"1085":{"type":"blank","loc":1085},"1086":{"type":"identifier","text":"@","loc":1086},"1087":{"type":"identifier","text":"123","loc":1087},"1088":{"type":"blank","loc":1088},"1089":{"type":"list","values":[1090,1091,1435],"loc":1089},"1090":{"type":"identifier","text":",","loc":1090},"1091":{"type":"list","values":[1093,1094],"loc":1091},"1092":{"type":"blank","loc":1092},"1093":{"type":"identifier","text":"@","loc":1093},"1094":{"type":"identifier","text":"hi","loc":1094},"1095":{"type":"blank","loc":1095},"1098":{"type":"list","values":[1099,1100,1433],"loc":1098},"1099":{"type":"identifier","text":",","loc":1099},"1100":{"type":"list","values":[1102,1103],"loc":1100},"1101":{"type":"blank","loc":1101},"1102":{"type":"identifier","text":"@","loc":1102},"1103":{"type":"identifier","text":"false","loc":1103},"1104":{"type":"blank","loc":1104},"1105":{"type":"list","values":[1107,1108,1109],"loc":1105},"1107":{"type":"identifier","text":",","loc":1107},"1108":{"type":"raw-code","lang":"javascript","raw":"x => valueToString(parseType(x))","loc":1108},"1109":{"type":"array","values":[1110,1117,1126],"loc":1109},"1110":{"type":"list","values":[1111,1112,1116],"loc":1110},"1111":{"type":"identifier","text":",","loc":1111},"1112":{"type":"list","values":[1113,1114],"loc":1112},"1113":{"type":"identifier","text":"@","loc":1113},"1114":{"type":"identifier","text":"list","loc":1114},"1115":{"type":"blank","loc":1115},"1116":{"type":"raw-code","lang":"javascript","raw":"'(tcon \"list\" 1114)'","loc":1116},"1117":{"type":"list","values":[1118,1119,1140],"loc":1117},"1118":{"type":"identifier","text":",","loc":1118},"1119":{"type":"list","values":[1121,1122],"loc":1119},"1120":{"type":"blank","loc":1120},"1121":{"type":"identifier","text":"@","loc":1121},"1122":{"type":"list","values":[1123,1124,1143],"loc":1122},"1123":{"type":"identifier","text":"list","loc":1123},"1124":{"type":"identifier","text":"a","loc":1124},"1125":{"type":"blank","loc":1125},"1126":{"type":"list","values":[1127,1128,1141],"loc":1126},"1127":{"type":"identifier","text":",","loc":1127},"1128":{"type":"list","values":[1130,1131],"loc":1128},"1129":{"type":"blank","loc":1129},"1130":{"type":"identifier","text":"@","loc":1130},"1131":{"type":"list","values":[1135,1136,1138],"loc":1131},"1135":{"type":"identifier","text":"fn","loc":1135},"1136":{"type":"array","values":[1137],"loc":1136},"1137":{"type":"identifier","text":"x","loc":1137},"1138":{"type":"identifier","text":"10","loc":1138},"1139":{"type":"blank","loc":1139},"1140":{"type":"raw-code","lang":"javascript","loc":1140,"raw":"'(tapp (tcon \"list\" 1123) (tcon \"a\" 1124) 1122)'"},"1141":{"type":"raw-code","lang":"javascript","loc":1141,"raw":"'(tapp (tapp (tcon \"->\" 1131) (tcon \"x\" 1137) 1131) (tcon \"10\" 1138) 1131)'"},"1143":{"type":"comment","text":" a comment is ignored","loc":1143},"1144":{"type":"array","values":[1146],"loc":1144},"1163":{"type":"list","values":[1164,118],"loc":1163},"1164":{"type":"identifier","text":"@","loc":1164},"1165":{"type":"list","values":[1166,1167,1171],"loc":1165},"1166":{"type":"identifier","text":",","loc":1166},"1167":{"type":"list","values":[1169,1170],"loc":1167},"1168":{"type":"blank","loc":1168},"1169":{"type":"identifier","text":"@","loc":1169},"1170":{"type":"identifier","text":"true","loc":1170},"1171":{"type":"raw-code","lang":"javascript","loc":1171,"raw":"\"(eprim (pbool true 1170) 1170)\""},"1172":{"type":"raw-code","lang":"javascript","loc":1172,"raw":"'(evar \"nil\" 118)'"},"1173":{"type":"list","values":[1174,1175,1182],"loc":1173},"1174":{"type":"identifier","text":",","loc":1174},"1175":{"type":"list","values":[1177,1178],"loc":1175},"1176":{"type":"blank","loc":1176},"1177":{"type":"identifier","text":"@","loc":1177},"1178":{"type":"array","values":[1179,1181],"loc":1178},"1179":{"type":"identifier","text":"1","loc":1179},"1181":{"type":"identifier","text":"2","loc":1181},"1182":{"type":"raw-code","lang":"javascript","loc":1182,"raw":"'(eapp (eapp (evar \"cons\" -1) (eprim (pint 1 1179) 1179) -1) (eapp (eapp (evar \"cons\" 1178) (eprim (pint 2 1181) 1181) 1178) (evar \"nil\" 1178) 1178) -1)'"},"1183":{"type":"raw-code","lang":"javascript","loc":1183,"raw":"'(elambda \"a\" (eprim (pint 1 133) 133) 129)'"},"1184":{"type":"raw-code","lang":"javascript","loc":1184,"raw":"'(ematch (evar \"x\" 161) [(, (pprim (pint 1 162) 162) (eprim (pint 2 163) 163)) (, (pstr \"hi\" 164) (eprim (pint 1 166) 166))] 157)'"},"1185":{"type":"raw-code","lang":"javascript","loc":1185,"raw":"'(ematch (evar \"c\" 185) [(, (pcon \",\" [(pvar \"a\" 182) (pvar \"b\" 184)] 180) (evar \"d\" 186))] 175)'"},"1186":{"type":"raw-code","lang":"javascript","loc":1186,"raw":"'(ematch (evar \"c\" 208) [(, (pcon \"cons\" [(pvar \"a\" 203) (pvar \"b\" 204)] 202) (evar \"d\" 209))] 196)'"},"1187":{"type":"raw-code","lang":"javascript","loc":1187,"raw":"'(eapp (eapp (evar \"cons\" -1) (evar \"a\" 790) -1) (evar \"b\" 791) -1)'"},"1188":{"type":"raw-code","lang":"javascript","loc":1188,"raw":"\"(eprim (pint 1 89) 89)\""},"1189":{"type":"list","values":[1190,1191,1201],"loc":1189},"1190":{"type":"identifier","text":",","loc":1190},"1191":{"type":"list","values":[1196,1197],"loc":1191},"1192":{"type":"blank","loc":1192},"1195":{"type":"stringText","loc":1195,"text":""},"1196":{"type":"identifier","text":"@","loc":1196},"1197":{"type":"string","first":1198,"templates":[{"expr":1199,"suffix":1200}],"loc":1197},"1198":{"type":"stringText","loc":1198,"text":"hi "},"1199":{"type":"identifier","text":"name","loc":1199},"1200":{"type":"stringText","text":"!","loc":1200},"1201":{"type":"raw-code","lang":"javascript","loc":1201,"raw":"'(estr \"hi \" [(, (evar \"name\" 1199) \"!\")] 1197)'"},"1202":{"type":"list","values":[1203,1204,1208],"loc":1202},"1203":{"type":"identifier","text":",","loc":1203},"1204":{"type":"list","values":[1206,1207],"loc":1204},"1205":{"type":"blank","loc":1205},"1206":{"type":"identifier","text":"@@","loc":1206},"1207":{"type":"identifier","text":"abc","loc":1207},"1208":{"type":"raw-code","lang":"javascript","loc":1208,"raw":"'(equot (cst/identifier \"abc\" 1207) 1204)'"},"1219":{"type":"identifier","text":",","loc":1219},"1220":{"type":"raw-code","lang":"javascript","raw":"x => valueToString(parsePat(x))","loc":1220},"1221":{"type":"array","values":[1222,1229,1236,1246,1253,1274,1281],"loc":1221},"1222":{"type":"list","values":[1223,1224,1228],"loc":1222},"1223":{"type":"identifier","text":",","loc":1223},"1224":{"type":"list","values":[1225,1226],"loc":1224},"1225":{"type":"identifier","text":"@","loc":1225},"1226":{"type":"identifier","text":"hi","loc":1226},"1227":{"type":"blank","loc":1227},"1228":{"type":"raw-code","lang":"javascript","loc":1228,"raw":"'(pvar \"hi\" 1226)'"},"1229":{"type":"list","values":[1230,1231,1235],"loc":1229},"1230":{"type":"identifier","text":",","loc":1230},"1231":{"type":"list","values":[1233,1234],"loc":1231},"1232":{"type":"blank","loc":1232},"1233":{"type":"identifier","text":"@","loc":1233},"1234":{"type":"identifier","text":"_","loc":1234},"1235":{"type":"raw-code","lang":"javascript","loc":1235,"raw":"\"(pany 1234)\""},"1236":{"type":"list","values":[1237,1238,1245],"loc":1236},"1237":{"type":"identifier","text":",","loc":1237},"1238":{"type":"list","values":[1240,1241],"loc":1238},"1239":{"type":"blank","loc":1239},"1240":{"type":"identifier","text":"@","loc":1240},"1241":{"type":"list","values":[1242,1243,1244],"loc":1241},"1242":{"type":"identifier","text":",","loc":1242},"1243":{"type":"identifier","text":"a","loc":1243},"1244":{"type":"identifier","text":"b","loc":1244},"1245":{"type":"raw-code","lang":"javascript","loc":1245,"raw":"'(pcon \",\" [(pvar \"a\" 1243) (pvar \"b\" 1244)] 1241)'"},"1246":{"type":"list","values":[1247,1248,1252],"loc":1246},"1247":{"type":"identifier","text":",","loc":1247},"1248":{"type":"list","values":[1250,1251],"loc":1248},"1249":{"type":"blank","loc":1249},"1250":{"type":"identifier","text":"@","loc":1250},"1251":{"type":"array","values":[],"loc":1251},"1252":{"type":"raw-code","lang":"javascript","loc":1252,"raw":"'(pcon \"nil\" [] 1251)'"},"1253":{"type":"list","values":[1254,1255,1273],"loc":1253},"1254":{"type":"identifier","text":",","loc":1254},"1255":{"type":"list","values":[1257,1258],"loc":1255},"1256":{"type":"blank","loc":1256},"1257":{"type":"identifier","text":"@","loc":1257},"1258":{"type":"array","values":[1263,1268,1272],"loc":1258},"1263":{"type":"identifier","text":"a","loc":1263},"1267":{"type":"spread","contents":1264,"loc":1267},"1268":{"type":"identifier","text":"b","loc":1268},"1269":{"type":"identifier","text":"c","loc":1269},"1272":{"type":"spread","contents":1269,"loc":1272},"1273":{"type":"raw-code","lang":"javascript","loc":1273,"raw":"'(pcon \"cons\" [(pvar \"a\" 1263) (pcon \"cons\" [(pvar \"b\" 1268) (pvar \"c\" 1269)] 1258)] 1258)'"},"1274":{"type":"list","values":[1275,1276,1280],"loc":1274},"1275":{"type":"identifier","text":",","loc":1275},"1276":{"type":"list","values":[1278,1279],"loc":1276},"1277":{"type":"blank","loc":1277},"1278":{"type":"identifier","text":"@","loc":1278},"1279":{"type":"identifier","text":"12","loc":1279},"1280":{"type":"raw-code","lang":"javascript","loc":1280,"raw":"\"(pprim (pint 12 1279) 1279)\""},"1281":{"type":"list","values":[1282,1283,1288],"loc":1281},"1282":{"type":"identifier","text":",","loc":1282},"1283":{"type":"list","values":[1285,1286],"loc":1283},"1284":{"type":"blank","loc":1284},"1285":{"type":"identifier","text":"@","loc":1285},"1286":{"type":"string","first":1287,"templates":[],"loc":1286},"1287":{"type":"stringText","loc":1287,"text":"hi"},"1288":{"type":"raw-code","lang":"javascript","loc":1288,"raw":"'(pstr \"hi\" 1286)'"},"1289":{"type":"raw-code","lang":"javascript","loc":1289,"raw":"\"(sexpr (eprim (pint 1 238) 238) 238)\""},"1290":{"type":"raw-code","lang":"javascript","loc":1290,"raw":"'(sdef \"hi\" (eprim (pint 10 254) 254) 245)'"},"1291":{"type":"raw-code","lang":"javascript","loc":1291,"raw":"'(sdef \"lol\" (elambda \"a\" (elambda \"b\" (eapp (eapp (evar \"+\" 271) (evar \"a\" 272) 270) (evar \"b\" 273) 270) 261) 261) 261)'"},"1292":{"type":"raw-code","lang":"javascript","loc":1292,"raw":"'(sdeftype \"option\" [(,, \"some\" [(tcon \"a\" 1018)] 1017) (,, \"none\" [] 1020)])'"},"1293":{"type":"rich-text","contents":[{"id":"3b556102-d698-4016-a8c6-5daa7e99e24a","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Primitives","styles":{}}],"children":[]},{"id":"c8d13d61-7d3b-4273-90c9-cc3acd955efb","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"just ints and booleans at the moment","styles":{}}],"children":[]}],"loc":1293},"1295":{"type":"rich-text","contents":[{"id":"907b09e0-9690-4fbc-9771-7a9a519ed5e5","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Types","styles":{}}],"children":[]}],"loc":1295},"1297":{"type":"raw-code","lang":"javascript","loc":1297,"raw":"{\"0\":1,\"1\":2,\"type\":\",\"}"},"1298":{"type":"identifier","text":"10","loc":1298},"1299":{"type":"blank","loc":1299},"1300":{"type":"blank","loc":1300},"1304":{"type":"raw-code","lang":"javascript","loc":1304,"raw":"\"(, 5 2)\""},"1305":{"type":"raw-code","lang":"javascript","loc":1305,"raw":"\"(some 10)\""},"1306":{"type":"raw-code","lang":"javascript","loc":1306,"raw":"'(lol 1 true \"hi\")'"},"1307":{"type":"raw-code","lang":"javascript","loc":1307,"raw":"\"(com, 1 2)\""},"1308":{"type":"raw-code","lang":"javascript","loc":1308,"raw":"\"10\""},"1309":{"type":"raw-code","lang":"javascript","loc":1309,"raw":"\"0\""},"1322":{"type":"blank","loc":1322},"1333":{"type":"list","values":[1334,1335,1363],"loc":1333},"1334":{"type":"identifier","text":",","loc":1334},"1335":{"type":"array","values":[1337,1352],"loc":1335},"1336":{"type":"blank","loc":1336},"1337":{"type":"list","values":[1338,1339,1343,1347],"loc":1337},"1338":{"type":"identifier","text":"deftype","loc":1338},"1339":{"type":"list","values":[1340,1341],"loc":1339},"1340":{"type":"identifier","text":"option","loc":1340},"1341":{"type":"identifier","text":"a","loc":1341},"1343":{"type":"list","values":[1344,1345],"loc":1343},"1344":{"type":"identifier","text":"some","loc":1344},"1345":{"type":"identifier","text":"a","loc":1345},"1347":{"type":"list","values":[1348],"loc":1347},"1348":{"type":"identifier","text":"none","loc":1348},"1349":{"type":"blank","loc":1349},"1352":{"loc":1352,"type":"list","values":[1353,1354,1357,1360,1361,1362]},"1353":{"loc":1353,"type":"identifier","text":"match"},"1354":{"loc":1354,"type":"list","values":[1355,1356]},"1355":{"loc":1355,"type":"identifier","text":"some"},"1356":{"loc":1356,"type":"identifier","text":"10"},"1357":{"loc":1357,"type":"list","values":[1358,1359]},"1358":{"loc":1358,"type":"identifier","text":"some"},"1359":{"loc":1359,"type":"identifier","text":"v"},"1360":{"loc":1360,"type":"identifier","text":"v"},"1361":{"loc":1361,"type":"identifier","text":"_"},"1362":{"loc":1362,"type":"identifier","text":"5"},"1363":{"type":"raw-code","lang":"javascript","loc":1363,"raw":"\"10\""},"1364":{"type":"list","values":[1366,1367,1368],"loc":1364},"1366":{"type":"identifier","text":",","loc":1366},"1367":{"type":"raw-code","lang":"javascript","raw":"unescapeSlashes","loc":1367},"1368":{"type":"array","values":[1369,1375,1381,1387,1394],"loc":1368},"1369":{"type":"list","values":[1370,1371,1373],"loc":1369},"1370":{"type":"identifier","text":",","loc":1370},"1371":{"type":"string","first":1372,"templates":[],"loc":1371},"1372":{"type":"stringText","loc":1372,"text":"\\n"},"1373":{"type":"string","first":1374,"templates":[],"loc":1373},"1374":{"type":"stringText","loc":1374,"text":"\\n"},"1375":{"type":"list","values":[1376,1377,1378],"loc":1375},"1376":{"type":"identifier","text":",","loc":1376},"1377":{"type":"string","first":1379,"templates":[],"loc":1377},"1378":{"type":"string","first":1380,"templates":[],"loc":1378},"1379":{"type":"stringText","loc":1379,"text":"\\\\n"},"1380":{"type":"stringText","loc":1380,"text":"\\n"},"1381":{"type":"list","values":[1382,1383,1384],"loc":1381},"1382":{"type":"identifier","text":",","loc":1382},"1383":{"type":"string","first":1385,"templates":[],"loc":1383},"1384":{"type":"string","first":1386,"templates":[],"loc":1384},"1385":{"type":"stringText","loc":1385,"text":"\\\\\\\\n"},"1386":{"type":"stringText","loc":1386,"text":"\\\\n"},"1387":{"type":"list","values":[1388,1389,1390],"loc":1387},"1388":{"type":"identifier","text":",","loc":1388},"1389":{"type":"string","first":1391,"templates":[],"loc":1389},"1390":{"type":"string","first":1393,"templates":[],"loc":1390},"1391":{"type":"stringText","loc":1391,"text":"\\\\\\\\"},"1392":{"type":"stringText","loc":1392,"text":""},"1393":{"type":"stringText","loc":1393,"text":"\\\\"},"1394":{"type":"list","values":[1395,1396,1397],"loc":1394},"1395":{"type":"identifier","text":",","loc":1395},"1396":{"type":"string","first":1398,"templates":[],"loc":1396},"1397":{"type":"string","first":1399,"templates":[],"loc":1397},"1398":{"type":"stringText","loc":1398,"text":"\\\\\\n"},"1399":{"type":"stringText","loc":1399,"text":"\\\\\\n"},"1400":{"type":"list","values":[1402,1403,1404],"loc":1400},"1402":{"type":"identifier","text":",","loc":1402},"1403":{"type":"raw-code","lang":"javascript","raw":"sanitize","loc":1403},"1404":{"type":"array","values":[1405,1411,1417],"loc":1404},"1405":{"type":"list","values":[1406,1407,1409],"loc":1405},"1406":{"type":"identifier","text":",","loc":1406},"1407":{"type":"string","first":1408,"templates":[],"loc":1407},"1408":{"type":"stringText","loc":1408,"text":"hello-world"},"1409":{"type":"string","first":1410,"templates":[],"loc":1409},"1410":{"type":"stringText","loc":1410,"text":"hello_world"},"1411":{"type":"list","values":[1412,1413,1414],"loc":1411},"1412":{"type":"identifier","text":",","loc":1412},"1413":{"type":"string","first":1415,"templates":[],"loc":1413},"1414":{"type":"string","first":1416,"templates":[],"loc":1414},"1415":{"type":"stringText","loc":1415,"text":"a/b/c"},"1416":{"type":"stringText","loc":1416,"text":"a$slb$slc"},"1417":{"type":"list","values":[1418,1419,1420],"loc":1417},"1418":{"type":"identifier","text":",","loc":1418},"1419":{"type":"string","first":1421,"templates":[],"loc":1419},"1420":{"type":"string","first":1422,"templates":[],"loc":1420},"1421":{"type":"stringText","loc":1421,"text":"abc$"},"1422":{"type":"stringText","loc":1422,"text":"abc$$"},"1423":{"type":"list","values":[1425,1426,1427],"loc":1423},"1425":{"type":"identifier","text":",","loc":1425},"1426":{"type":"raw-code","lang":"javascript","raw":"makePairs","loc":1426},"1427":{"type":"array","values":[1428],"loc":1427},"1428":{"type":"list","values":[1429,1430,1431],"loc":1428},"1429":{"type":"identifier","text":",","loc":1429},"1430":{"type":"raw-code","lang":"javascript","raw":"[1, 2, 3, 4]","loc":1430},"1431":{"type":"raw-code","lang":"javascript","raw":"[[1, 2], [3, 4]]","loc":1431},"1432":{"type":"raw-code","lang":"javascript","loc":1432,"raw":"\"(eprim (pbool true 1080) 1080)\""},"1433":{"type":"raw-code","lang":"javascript","loc":1433,"raw":"\"(eprim (pbool false 1103) 1103)\""},"1434":{"type":"raw-code","lang":"javascript","loc":1434,"raw":"\"(eprim (pint 123 1087) 1087)\""},"1435":{"type":"raw-code","lang":"javascript","loc":1435,"raw":"'\"not a prim\"'"},"-1":{"type":"list","values":[0],"loc":-1}},"root":-1,"meta":{},"history":[{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined \n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined ne\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2747,"ts":1714869617.335,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined ne\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined nex\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2748,"ts":1714869617.554,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined nex\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2749,"ts":1714869617.69,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2750,"ts":1714869617.845,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2751,"ts":1714869630.739,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      /\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2752,"ts":1714869630.98,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      /\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      //\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2753,"ts":1714869631.136,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      //\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2754,"ts":1714869631.253,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // O\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2755,"ts":1714869631.337,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // O\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Ot\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2756,"ts":1714869631.476,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Ot\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Othe\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2757,"ts":1714869631.623,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Othe\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Other\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2758,"ts":1714869632.077,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Other\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherw\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2759,"ts":1714869632.788,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherw\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwi\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2760,"ts":1714869632.876,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwi\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2761,"ts":1714869633.097,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2762,"ts":1714869633.229,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2763,"ts":1714869633.773,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2764,"ts":1714869633.971,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do f\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2765,"ts":1714869634.346,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do f\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do fun\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2766,"ts":1714869634.435,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do fun\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do func\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2767,"ts":1714869634.478,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do func\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do functi\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2768,"ts":1714869634.651,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do functi\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do functio\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2769,"ts":1714869634.704,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do functio\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2770,"ts":1714869634.825,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2771,"ts":1714869634.928,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function ap\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2772,"ts":1714869635.055,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function ap\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function appl\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2773,"ts":1714869635.25,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function appl\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function applic\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2774,"ts":1714869635.456,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function applic\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function applicat\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2775,"ts":1714869635.608,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function applicat\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function applicatio\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2776,"ts":1714869635.682,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function applicatio\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2777,"ts":1714869635.792,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application.\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2778,"ts":1714869636.002,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application.\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2779,"ts":1714869637.516,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. R\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2780,"ts":1714869637.698,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. R\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Re\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2781,"ts":1714869637.879,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Re\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Rem\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2782,"ts":1714869637.947,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Rem\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remem\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2783,"ts":1714869638.055,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remem\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remembe\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2784,"ts":1714869638.243,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remembe\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2785,"ts":1714869638.338,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember t\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2786,"ts":1714869638.434,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember t\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember tha\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2787,"ts":1714869638.573,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember tha\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2788,"ts":1714869638.69,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2789,"ts":1714869638.842,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2790,"ts":1714869643.956,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we'\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2791,"ts":1714869643.994,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we'\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2792,"ts":1714869644.339,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2793,"ts":1714869644.72,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're a\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2794,"ts":1714869644.94,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're a\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're aut\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2795,"ts":1714869645.016,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're aut\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2796,"ts":1714869645.21,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2797,"ts":1714869645.848,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2798,"ts":1714869645.982,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-cu\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2799,"ts":1714869646.099,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-cu\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-cur\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2800,"ts":1714869646.168,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-cur\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-curr\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2801,"ts":1714869646.301,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-curr\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-curry\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2802,"ts":1714869646.62,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-curry\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-curryin\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2803,"ts":1714869646.907,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-curryin\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2804,"ts":1714869647.053,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2805,"ts":1714869647.181,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2806,"ts":1714869647.423,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      /\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2807,"ts":1714869647.613,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      /\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2808,"ts":1714869647.782,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2809,"ts":1714869648.139,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2810,"ts":1714869648.282,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2811,"ts":1714869648.395,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2812,"ts":1714869649.124,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2813,"ts":1714869649.355,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2814,"ts":1714869649.516,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2815,"ts":1714869649.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b cd\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2816,"ts":1714869649.915,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b cd\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b cd \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2817,"ts":1714869650.465,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b cd \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b cd\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2818,"ts":1714869650.631,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b cd\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2819,"ts":1714869650.792,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2820,"ts":1714869650.909,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2821,"ts":1714869651.085,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2822,"ts":1714869651.402,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2823,"ts":1714869651.714,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2824,"ts":1714869652.091,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2825,"ts":1714869652.182,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is s\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2826,"ts":1714869652.545,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is s\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sug\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2827,"ts":1714869652.628,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sug\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2828,"ts":1714869652.835,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2829,"ts":1714869652.915,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar f\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2830,"ts":1714869653.078,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar f\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2831,"ts":1714869653.216,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2832,"ts":1714869653.255,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2833,"ts":1714869653.467,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for ((\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2834,"ts":1714869654.196,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for ((\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2835,"ts":1714869654.359,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2836,"ts":1714869654.805,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2837,"ts":1714869654.886,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2838,"ts":1714869655.045,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2839,"ts":1714869655.309,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2840,"ts":1714869655.424,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2841,"ts":1714869655.691,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2842,"ts":1714869655.826,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2843,"ts":1714869656.277,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2844,"ts":1714869656.618,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2845,"ts":1714869656.7,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) \n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2846,"ts":1714869656.883,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2847,"ts":1714869657.135,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2848,"ts":1714869673.286,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      /\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2849,"ts":1714869673.463,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      /\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      //\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2850,"ts":1714869673.606,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      //\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2851,"ts":1714869674.073,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2852,"ts":1714869674.601,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2853,"ts":1714869674.714,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a f\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2854,"ts":1714869674.871,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a f\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a fin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2855,"ts":1714869674.978,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a fin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a fina\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2856,"ts":1714869675.004,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a fina\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2857,"ts":1714869675.125,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2858,"ts":1714869675.217,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2859,"ts":1714869677.034,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `sp\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2860,"ts":1714869677.767,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `sp\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spre\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2861,"ts":1714869677.963,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spre\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2862,"ts":1714869678.094,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread`\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2863,"ts":1714869678.427,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread`\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2864,"ts":1714869678.899,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` no\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2865,"ts":1714869679.125,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` no\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` nod\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2866,"ts":1714869679.181,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` nod\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2867,"ts":1714869679.269,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2868,"ts":1714869686.436,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2869,"ts":1714869686.534,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2870,"ts":1714869686.666,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is n\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2871,"ts":1714869686.931,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is n\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is nea\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2872,"ts":1714869687.017,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is nea\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neat\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2873,"ts":1714869687.237,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neat\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2874,"ts":1714869687.441,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2875,"ts":1714869687.66,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly re\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2876,"ts":1714869687.873,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly re\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly rep\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2877,"ts":1714869688.061,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly rep\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly repre\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2878,"ts":1714869688.178,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly repre\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly repres\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2879,"ts":1714869688.352,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly repres\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly represe\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2880,"ts":1714869688.513,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly represe\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly represent\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2881,"ts":1714869688.652,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly represent\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly represente\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2882,"ts":1714869688.699,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly represente\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2883,"ts":1714869688.924,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2884,"ts":1714869690.058,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      /\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2885,"ts":1714869690.269,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      /\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2886,"ts":1714869690.436,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2887,"ts":1714869691.152,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2888,"ts":1714869691.254,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a n\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2889,"ts":1714869691.396,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a n\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a nr\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2890,"ts":1714869691.526,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a nr\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a nro\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2891,"ts":1714869691.606,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a nro\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a nr\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2892,"ts":1714869692.161,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a nr\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a n\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2893,"ts":1714869692.284,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a n\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a no\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2894,"ts":1714869692.5,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a no\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a nor\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2895,"ts":1714869692.61,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a nor\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norm\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2896,"ts":1714869692.711,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norm\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norma\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2897,"ts":1714869692.879,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norma\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2898,"ts":1714869693.269,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2899,"ts":1714869693.402,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal a\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2900,"ts":1714869694.319,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal a\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal ar\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2901,"ts":1714869694.483,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal ar\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal arra\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2902,"ts":1714869694.624,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal arra\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2903,"ts":1714869694.752,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2904,"ts":1714869695.015,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array l\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2905,"ts":1714869695.097,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array l\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array lo\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2906,"ts":1714869695.273,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array lo\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array look\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2907,"ts":1714869695.459,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array look\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array looks\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2908,"ts":1714869695.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal array looks\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2909,"ts":1714869696.403,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norma\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2910,"ts":1714869696.568,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norma\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norma \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2911,"ts":1714869696.885,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norma \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norma\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2912,"ts":1714869697.159,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a norma\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2913,"ts":1714869697.478,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2914,"ts":1714869697.575,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal li\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2915,"ts":1714869697.747,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal li\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal lis\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2916,"ts":1714869697.799,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal lis\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2917,"ts":1714869697.895,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2918,"ts":1714869698.528,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2919,"ts":1714869698.685,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2920,"ts":1714869698.836,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2921,"ts":1714869699.091,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2922,"ts":1714869699.291,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2923,"ts":1714869699.545,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3]\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2924,"ts":1714869699.734,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3]\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2925,"ts":1714869701.043,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] t\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2926,"ts":1714869701.58,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] t\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] tur\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2927,"ts":1714869701.657,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] tur\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2928,"ts":1714869701.84,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2929,"ts":1714869702.013,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns in\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2930,"ts":1714869702.105,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns in\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns int\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2931,"ts":1714869702.141,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns int\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2932,"ts":1714869702.305,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2933,"ts":1714869702.389,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2934,"ts":1714869702.544,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (on\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2935,"ts":1714869702.828,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (on\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (o\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2936,"ts":1714869703.103,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (o\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2937,"ts":1714869703.227,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (c\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2938,"ts":1714869703.322,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (c\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (con\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2939,"ts":1714869703.452,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (con\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2940,"ts":1714869703.499,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2941,"ts":1714869703.567,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2942,"ts":1714869703.938,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2943,"ts":1714869704.067,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2944,"ts":1714869704.495,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (c\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2945,"ts":1714869704.679,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (c\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (con\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2946,"ts":1714869704.771,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (con\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2947,"ts":1714869704.821,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2948,"ts":1714869705.017,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2949,"ts":1714869705.114,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2950,"ts":1714869705.613,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2951,"ts":1714869705.847,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (c\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2952,"ts":1714869706.232,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (c\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (con\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2953,"ts":1714869706.348,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (con\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (con \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2954,"ts":1714869706.579,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (con \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (con\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2955,"ts":1714869706.895,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (con\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2956,"ts":1714869707.049,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2957,"ts":1714869707.133,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2958,"ts":1714869707.458,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 \n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2959,"ts":1714869707.826,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2960,"ts":1714869708.197,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil))\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2961,"ts":1714869708.361,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil))\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2962,"ts":1714869708.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2963,"ts":1714869713.083,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2964,"ts":1714869713.155,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2965,"ts":1714869713.324,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by re\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2966,"ts":1714869717.636,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by re\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by repl\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2967,"ts":1714869717.779,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by repl\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by repla\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2968,"ts":1714869717.991,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by repla\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replac\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2969,"ts":1714869718.322,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replac\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2970,"ts":1714869718.452,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2971,"ts":1714869718.499,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing t\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2972,"ts":1714869718.66,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing t\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing th\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2973,"ts":1714869718.81,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing th\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2974,"ts":1714869718.963,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2975,"ts":1714869719.168,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      /\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2976,"ts":1714869719.719,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      /\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2977,"ts":1714869719.882,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // f\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2978,"ts":1714869719.953,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // f\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2979,"ts":1714869720.134,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fina\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2980,"ts":1714869720.158,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fina\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2981,"ts":1714869720.543,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fi\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2982,"ts":1714869720.685,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fi\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // f\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2983,"ts":1714869720.839,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // f\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2984,"ts":1714869721.243,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // f\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2985,"ts":1714869723.006,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // f\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2986,"ts":1714869723.18,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // fin\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2987,"ts":1714869723.368,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2988,"ts":1714869723.43,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2989,"ts":1714869723.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2990,"ts":1714869723.959,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil`\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2991,"ts":1714869724.177,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil`\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2992,"ts":1714869725.603,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` w\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2993,"ts":1714869729.021,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` w\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` wit\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2994,"ts":1714869729.099,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` wit\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2995,"ts":1714869729.195,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2996,"ts":1714869729.349,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with th\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2997,"ts":1714869730.549,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with th\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with tha\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2998,"ts":1714869730.806,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with tha\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with th\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":2999,"ts":1714869731.029,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with th\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3000,"ts":1714869731.186,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3001,"ts":1714869731.27,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3002,"ts":1714869731.444,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the con\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3003,"ts":1714869731.579,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the con\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the cont\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3004,"ts":1714869731.606,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the cont\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the conte\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3005,"ts":1714869731.686,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the conte\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the content\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3006,"ts":1714869731.814,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the content\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3007,"ts":1714869731.894,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3008,"ts":1714869732.018,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3009,"ts":1714869732.173,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3010,"ts":1714869732.253,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of th\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3011,"ts":1714869732.55,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of th\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3012,"ts":1714869732.757,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3013,"ts":1714869732.817,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the s\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3014,"ts":1714869732.971,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the s\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spr\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3015,"ts":1714869733.112,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spr\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spre\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3016,"ts":1714869733.196,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spre\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the sprea\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3017,"ts":1714869733.255,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the sprea\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3018,"ts":1714869733.301,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3019,"ts":1714869734.237,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3020,"ts":1714869735.098,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      /\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3021,"ts":1714869735.28,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      /\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3022,"ts":1714869735.416,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // s\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3023,"ts":1714869735.602,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // s\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3024,"ts":1714869735.694,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3025,"ts":1714869735.794,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3026,"ts":1714869735.963,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3027,"ts":1714869736.341,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3028,"ts":1714869736.432,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a .\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3029,"ts":1714869736.568,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a .\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3030,"ts":1714869736.736,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3031,"ts":1714869736.904,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..b]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3032,"ts":1714869737.033,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..b]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3033,"ts":1714869737.696,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3034,"ts":1714869737.831,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a ..\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a .\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3035,"ts":1714869737.972,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a .\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3036,"ts":1714869738.114,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3037,"ts":1714869738.247,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3038,"ts":1714869738.451,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b .\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3039,"ts":1714869738.808,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b .\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3040,"ts":1714869738.953,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3041,"ts":1714869739.059,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3042,"ts":1714869739.177,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3043,"ts":1714869739.445,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3044,"ts":1714869739.557,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] be\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3045,"ts":1714869739.634,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] be\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] bec\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3046,"ts":1714869739.936,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] bec\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becom\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3047,"ts":1714869740.098,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becom\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3048,"ts":1714869740.242,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3049,"ts":1714869740.443,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3050,"ts":1714869741.218,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3051,"ts":1714869741.4,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (con\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3052,"ts":1714869741.492,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (con\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3053,"ts":1714869741.54,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3054,"ts":1714869741.628,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3055,"ts":1714869742.409,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3056,"ts":1714869742.78,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3057,"ts":1714869742.915,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3058,"ts":1714869743.128,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (con\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3059,"ts":1714869743.22,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (con\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3060,"ts":1714869743.374,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3061,"ts":1714869743.535,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3062,"ts":1714869743.821,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3063,"ts":1714869744.164,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3064,"ts":1714869744.282,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cond\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (con\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3065,"ts":1714869744.434,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (con\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3066,"ts":1714869744.585,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3067,"ts":1714869744.794,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3068,"ts":1714869745.25,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b \n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3069,"ts":1714869745.46,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c)\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3070,"ts":1714869745.705,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c)\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3071,"ts":1714869745.863,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}],"end":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"idx":33,"type":"end"}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3072,"ts":1714869758.446,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    /\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3073,"ts":1714869758.65,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    /\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    //\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3074,"ts":1714869758.803,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    //\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3075,"ts":1714869758.993,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // f\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3076,"ts":1714869759.989,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // f\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3077,"ts":1714869760.091,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for o\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3078,"ts":1714869760.279,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for o\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for ou\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3079,"ts":1714869760.366,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for ou\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3080,"ts":1714869760.409,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3081,"ts":1714869760.514,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our l\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3082,"ts":1714869760.6,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our l\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our la\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3083,"ts":1714869760.789,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our la\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our lan\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3084,"ts":1714869760.882,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our lan\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our lang\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3085,"ts":1714869760.965,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our lang\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our langua\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3086,"ts":1714869761.076,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our langua\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3087,"ts":1714869761.236,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language,\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3088,"ts":1714869761.314,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language,\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3089,"ts":1714869761.391,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3090,"ts":1714869761.458,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, th\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3091,"ts":1714869761.518,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, th\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3092,"ts":1714869761.671,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3093,"ts":1714869761.905,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `r\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3094,"ts":1714869762.134,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `r\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3095,"ts":1714869762.254,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3096,"ts":1714869762.322,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-c\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3097,"ts":1714869762.515,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-c\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-cod\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3098,"ts":1714869762.62,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-cod\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3099,"ts":1714869762.786,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code`\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3100,"ts":1714869763.053,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code`\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3101,"ts":1714869763.218,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` no\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3102,"ts":1714869763.527,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` no\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` nod\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3103,"ts":1714869763.581,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` nod\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3104,"ts":1714869763.653,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3105,"ts":1714869765.494,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node j\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3106,"ts":1714869765.578,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node j\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node jus\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3107,"ts":1714869765.743,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node jus\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3108,"ts":1714869765.837,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3109,"ts":1714869765.913,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just ge\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3110,"ts":1714869766.633,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just ge\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just get\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3111,"ts":1714869766.725,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just get\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3112,"ts":1714869766.781,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3113,"ts":1714869766.906,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets pa\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3114,"ts":1714869767.222,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets pa\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets pas\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3115,"ts":1714869767.395,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets pas\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets pass\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3116,"ts":1714869767.515,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets pass\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passe\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3117,"ts":1714869767.931,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passe\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3118,"ts":1714869768.085,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3119,"ts":1714869768.177,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3120,"ts":1714869768.345,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed th\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3121,"ts":1714869768.589,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed th\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed thr\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3122,"ts":1714869768.733,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed thr\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed throu\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3123,"ts":1714869768.829,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed throu\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed throug\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3124,"ts":1714869768.969,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed throug\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3125,"ts":1714869769.073,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3126,"ts":1714869769.354,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3127,"ts":1714869769.437,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3128,"ts":1714869769.67,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3129,"ts":1714869769.767,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a ru\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3130,"ts":1714869770.609,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a ru\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a run\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3131,"ts":1714869770.661,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a run\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runt\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3132,"ts":1714869770.714,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runt\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtim\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3133,"ts":1714869770.897,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtim\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3134,"ts":1714869770.949,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3135,"ts":1714869771.021,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime str\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3136,"ts":1714869771.344,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime str\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime stri\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3137,"ts":1714869771.442,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime stri\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime strin\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3138,"ts":1714869771.504,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime strin\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3139,"ts":1714869771.549,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3140,"ts":1714869772.883,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3141,"ts":1714869773.069,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    /\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3142,"ts":1714869773.271,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    /\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    //\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3143,"ts":1714869773.42,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    //\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3144,"ts":1714869773.523,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3145,"ts":1714869774.139,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3146,"ts":1714869774.226,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we ca\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3147,"ts":1714869774.367,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we ca\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3148,"ts":1714869774.465,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3149,"ts":1714869774.606,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can ca\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3150,"ts":1714869774.875,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can ca\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can cal\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3151,"ts":1714869774.98,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can cal\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3152,"ts":1714869775.148,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3153,"ts":1714869775.323,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3154,"ts":1714869776.292,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `ev\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3155,"ts":1714869776.363,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `ev\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3156,"ts":1714869776.551,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval`\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3157,"ts":1714869776.817,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval`\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3158,"ts":1714869777.057,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3159,"ts":1714869777.265,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3160,"ts":1714869777.314,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3161,"ts":1714869777.543,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3162,"ts":1714869777.686,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3163,"ts":1714869778.805,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3164,"ts":1714869778.861,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3165,"ts":1714869779.1,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3166,"ts":1714869779.159,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we n\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3167,"ts":1714869779.203,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we n\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we ne\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3168,"ts":1714869779.293,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we ne\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we nee\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3169,"ts":1714869779.475,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we nee\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3170,"ts":1714869779.588,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3171,"ts":1714869779.697,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3172,"ts":1714869779.786,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3173,"ts":1714869779.846,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to b\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3174,"ts":1714869783.698,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to b\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to bai\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3175,"ts":1714869783.849,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to bai\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to bail\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3176,"ts":1714869783.949,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to bail\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3177,"ts":1714869789.507,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need to\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3178,"ts":1714869790.073,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3179,"ts":1714869790.243,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3180,"ts":1714869790.502,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3181,"ts":1714869790.674,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3182,"ts":1714869790.879,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an es\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3183,"ts":1714869791.06,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an es\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an esc\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3184,"ts":1714869791.181,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an esc\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an esca\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3185,"ts":1714869791.303,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an esca\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escap\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3186,"ts":1714869791.412,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escap\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3187,"ts":1714869791.629,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3188,"ts":1714869791.717,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape h\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3189,"ts":1714869792.189,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape h\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hat\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3190,"ts":1714869792.319,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hat\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3191,"ts":1714869792.585,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3192,"ts":1714869797.957,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch f\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3193,"ts":1714869798.6,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch f\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch fo\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3194,"ts":1714869798.709,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch fo\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3195,"ts":1714869798.817,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3196,"ts":1714869798.905,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3197,"ts":1714869799.035,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3198,"ts":1714869799.148,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3199,"ts":1714869799.24,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g.\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3200,"ts":1714869799.372,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g.\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3201,"ts":1714869799.489,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. p\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3202,"ts":1714869799.687,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. p\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. pr\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3203,"ts":1714869799.771,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. pr\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. prod\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3204,"ts":1714869799.889,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. prod\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. produ\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3205,"ts":1714869800.09,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. produ\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. produc\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3206,"ts":1714869800.272,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. produc\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producin\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3207,"ts":1714869800.38,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producin\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3208,"ts":1714869800.544,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3209,"ts":1714869800.75,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3210,"ts":1714869801.815,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing th\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3211,"ts":1714869801.91,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing th\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3212,"ts":1714869802.01,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3213,"ts":1714869803.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3214,"ts":1714869804.569,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3215,"ts":1714869804.757,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3216,"ts":1714869805.117,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    /\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3217,"ts":1714869805.402,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    /\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    //\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3218,"ts":1714869805.567,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    //\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3219,"ts":1714869805.697,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // ex\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3220,"ts":1714869805.962,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // ex\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expe\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3221,"ts":1714869806.051,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expe\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expec\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3222,"ts":1714869806.162,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expec\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expecte\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3223,"ts":1714869806.43,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expecte\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3224,"ts":1714869806.648,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3225,"ts":1714869806.784,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3226,"ts":1714869806.899,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3227,"ts":1714869807.133,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3228,"ts":1714869808.012,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by t\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3229,"ts":1714869808.126,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3230,"ts":1714869808.192,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the s\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3231,"ts":1714869808.598,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the s\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the str\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3232,"ts":1714869808.898,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the str\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the stru\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3233,"ts":1714869809.029,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the stru\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the struc\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3234,"ts":1714869809.105,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the struc\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the struct\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3235,"ts":1714869809.258,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the struct\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structu\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3236,"ts":1714869809.413,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structu\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structure\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3237,"ts":1714869809.588,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structure\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3238,"ts":1714869810.916,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3239,"ts":1714869811.049,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured \n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3240,"ts":1714869812.016,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured e\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured ed\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3241,"ts":1714869812.186,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured ed\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured edi\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3242,"ts":1714869812.335,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured edi\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured edit\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3243,"ts":1714869812.391,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured edit\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured edito\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3244,"ts":1714869812.627,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured edito\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured editor\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3245,"ts":1714869812.766,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured editor\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {\n        type: 'estr',\n        0: node.first.text,\n        1: list(node.templates.map((t, i) => pair(exprs[i], t.suffix.text))),\n        2: node.loc\n      }\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        // If we're in a list w/ the first item being an identifier, see if\n        // we're in a 'special form' (defined next)\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      // Otherwise do function application. Remember that we're auto-currying,\n      // so (a b c d) is sugar for (((a b) c) d)\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      // a normal list [1 2 3] turns into (cons 1 (cons 2 (cons 3 nil)))\n      // a final `spread` node is neatly represented by replacing the\n      // final `nil` with the contents of the spread.\n      // so [a b ..c] becomes (cons a (cons b c))\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    // for our language, the `raw-code` node just gets passed through as a runtime string.\n    // we can call `eval` on it if we need an escape hatch for e.g. producing the API\n    // expected by the structured editor.\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":3246,"ts":1714869812.91,"libraryRoot":""}],"clipboard":[],"hover":[],"regs":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"cards":[{"path":[],"top":0}],"nsMap":{"0":{"id":0,"top":-1,"children":[1,3,214,212,36,598,1059,575],"type":"normal"},"1":{"id":1,"top":0,"children":[],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3},"9":{"type":"normal","top":8,"children":[],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"22":{"type":"normal","top":21,"children":[],"id":22},"24":{"type":"normal","top":23,"children":[],"id":24},"26":{"type":"normal","top":25,"children":[28,30],"id":26,"collapsed":true},"28":{"type":"normal","top":27,"children":[],"id":28},"30":{"type":"normal","top":29,"children":[],"id":30},"34":{"type":"normal","top":33,"children":[],"id":34},"36":{"type":"normal","top":35,"children":[421,423,22,287,873,1365,276,370,336,456],"id":36,"collapsed":true},"43":{"type":"normal","top":42,"children":[],"id":43},"58":{"type":"normal","top":57,"children":[],"id":58},"69":{"type":"normal","top":68,"children":[],"id":69},"71":{"type":"normal","top":70,"children":[],"id":71},"77":{"type":"normal","top":76,"children":[],"id":77},"79":{"type":"normal","top":78,"children":[],"id":79,"plugin":{"id":"fixture","options":null}},"99":{"type":"normal","top":98,"children":[110],"id":99,"collapsed":true},"110":{"type":"normal","top":109,"children":[],"id":110},"112":{"type":"normal","top":111,"children":[],"id":112},"150":{"type":"normal","top":149,"children":[1424],"id":150},"189":{"type":"normal","top":188,"children":[],"id":189},"212":{"type":"normal","top":211,"children":[1294,1296,216,218,220],"id":212,"collapsed":false},"214":{"type":"normal","top":213,"children":[26,99,58,71,150,112,1023],"id":214,"collapsed":true},"216":{"type":"normal","top":215,"children":[34,69,24,802,79],"id":216,"collapsed":false},"218":{"type":"normal","top":217,"id":218,"children":[189,77,776],"collapsed":true},"220":{"type":"normal","top":219,"children":[222,226,230],"id":220,"collapsed":true},"222":{"type":"normal","top":221,"children":[],"id":222},"226":{"type":"normal","top":225,"children":[],"id":226},"230":{"type":"normal","top":229,"children":[],"id":230,"plugin":{"id":"fixture","options":null}},"276":{"type":"normal","top":275,"children":[],"id":276},"287":{"type":"normal","top":286,"children":[],"id":287},"336":{"type":"normal","top":335,"children":[],"id":336},"370":{"type":"normal","top":369,"children":[],"id":370,"plugin":{"id":"fixture","options":null}},"421":{"type":"normal","top":420,"id":421,"children":[]},"423":{"type":"normal","top":422,"children":[],"id":423},"456":{"type":"normal","top":455,"children":[],"id":456,"plugin":{"id":"fixture","options":null}},"571":{"type":"normal","top":570,"children":[],"id":571},"573":{"type":"normal","top":572,"children":[],"id":573},"575":{"type":"normal","top":576,"children":[],"id":575},"594":{"type":"normal","top":593,"children":[],"id":594},"596":{"type":"normal","top":595,"children":[],"id":596},"598":{"type":"normal","top":597,"id":598,"children":[600,690,612,614,608,602,692,694],"collapsed":true},"600":{"type":"normal","top":599,"children":[],"id":600},"602":{"type":"normal","top":601,"children":[],"id":602,"plugin":{"id":"fixture","options":null}},"608":{"type":"normal","top":607,"children":[],"id":608},"612":{"type":"normal","top":611,"children":[],"id":612},"614":{"type":"normal","top":613,"children":[],"id":614},"690":{"type":"normal","top":689,"children":[],"id":690},"692":{"type":"normal","top":691,"children":[],"id":692},"694":{"type":"normal","top":693,"children":[],"id":694,"plugin":{"id":"fixture","options":null}},"739":{"type":"normal","top":738,"children":[741],"id":739},"741":{"type":"normal","top":740,"children":[],"id":741},"755":{"type":"normal","top":754,"children":[1401,809,811,807],"id":755,"collapsed":false},"776":{"type":"normal","top":775,"children":[],"id":776,"plugin":{"id":"fixture","options":null}},"802":{"type":"normal","id":802,"top":803,"children":[]},"807":{"type":"normal","top":806,"children":[],"id":807},"809":{"type":"normal","top":808,"children":[],"id":809},"811":{"type":"normal","top":810,"children":[],"id":811},"873":{"type":"normal","top":872,"children":[],"id":873},"878":{"type":"normal","id":878,"top":879,"children":[],"display":{"id":"none","options":null}},"892":{"type":"normal","id":892,"top":893,"children":[],"display":{"id":"none","options":null},"collapsed":false},"924":{"type":"normal","id":924,"top":925,"children":[],"display":{"id":"none","options":null}},"934":{"type":"normal","id":934,"top":935,"children":[],"display":{"id":"none","options":null}},"955":{"type":"normal","id":955,"top":956,"children":[],"display":{"id":"none","options":null}},"969":{"type":"normal","id":969,"top":970,"children":[],"display":{"id":"none","options":null}},"998":{"type":"normal","top":997,"children":[],"id":998},"1023":{"type":"normal","top":1022,"children":[],"id":1023},"1059":{"type":"normal","top":1058,"children":[9,571,594,596,739,755,573],"id":1059,"collapsed":true},"1067":{"type":"normal","top":1066,"children":[],"id":1067,"plugin":{"id":"fixture","options":null}},"1078":{"type":"normal","top":1077,"children":[],"id":1078},"1106":{"type":"normal","top":1105,"children":[],"id":1106,"plugin":{"id":"fixture","options":null}},"1294":{"type":"normal","top":1293,"id":1294,"children":[43,1078,1067],"collapsed":true},"1296":{"type":"normal","top":1295,"children":[998,1106],"id":1296,"collapsed":true},"1365":{"type":"normal","top":1364,"children":[],"id":1365,"plugin":{"id":"fixture","options":null}},"1401":{"type":"normal","top":1400,"id":1401,"children":[],"plugin":{"id":"fixture","options":null}},"1424":{"type":"normal","top":1423,"children":[],"id":1424,"plugin":{"id":"fixture","options":null}}},"highlight":[],"evaluator":":js:"}