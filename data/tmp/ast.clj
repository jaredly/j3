(** ## Abstract Syntax Tree **)

(** Once we have our runtime encoding (primitives, functions, and algebraic data types), we need to decide on an Abstract Syntax Tree. Once again we'll keep the list relatively short, with the goal of "the simplest language that's still nice to use". **)

(** Utility Types **)

(deftype (list a) (nil) (cons a (list a)))

(deftype (, a b) (, a b))

(** ## Type Definitions **)

(** Some notes:
    - the final integer on each form represents the unique "location" ID of CST node that it came from. This allows us to do accurate error reporting and "hover for type" and such.
    - We're prefixing constructor names (e.g. p for prim, e for expr) to prevent name conflicts between the types, as they all share the same namespace. **)

(** ## Primitives
    We break out primitives into their own type, because they apply both to patterns and expressions. **)

(deftype prim (pint int int) (pbool bool int))

(** ## Expressions
    Expressions make up the bulk of the code you'll be writing: variable references, function definitions, function calls, etc. -- even if and let (in contrast to imperative languages such as JavaScript, where those would be statements). **)

(deftype expr
    (eprim prim int)
        (** A string! It doesn't get lumped in with the primitives, because it might have embedded expressions. This is inspired by JavaScript's template strings and swift's string interpolations. The first string is the "prefix", and if the string contains no interpolations, then the second list will be empty. Otherwise, it will contain a list of pairs, first the expression, and then the string suffix.
        So "Hello ${world}!" would parse into (estr "Hello" [(, (evar "world") "!")]) **)
        (estr string (list (, expr string int)) int)
        (** a variable reference! might be local or global. **)
        (evar string int)
        (** A lambda is a function expression (or "arrow function" in JavaScript). It consists of a list of arguments and a body. As our language has automatic currying, the arguments will be "unrolled", such that (fn [a b] c) is sugar for (fn [a] (fn [b] c)). **)
        (elambda (list pat) expr int)
        (** Function application (or "function call") consists of a target (the function) and a list of arguments. At runtime, these arguments are applied one-by-one. **)
        (eapp expr (list expr) int)
        (** let expressions have a list of bindings and a body where those bindings will be in scope. It values to the value of that body. **)
        (elet (list (, pat expr)) expr int)
        (** The "match" expression is analogous to a switch statement from JavaScript, Swift, or Rust. It has a target expression, and a list of cases. The first pattern that matches gets evaluated. **)
        (ematch expr (list (, pat expr)))
        (** The "quote" expression is mostly helpful for macros or if you're building a compiler. Our language doesn't have macros (yet? ğŸ˜‰) but we sure are building a compiler, so having full quoting support will be invaluable. In traditional lisps, the quote form is ' (such as '(a b)), but we'll be using @ for quoted expressions, @! for statements, @p for patterns, @t for types, and @@ for accessing the CST directly.
        Basically, if we want to test out type inference, we can do (infer/expr (@ [1 2 3])), and if we want to test parsing, we can do (parse/expr (@@ [1 2 3])). **)
        (equot quot int))

(deftype quot
    (quot/expr expr)
        (quot/stmt stmt)
        (quot/type type)
        (quot/pat pat)
        (quot/quot cst))

(** ## Patterns
    Sometimes referred to as l-values (things that can go on the "left hand of an assignment"), patterns show up as function arguments, the left side of a let binding, or in match cases.  **)

(deftype pat
    (** the "any" pattern is an underscore _ **)
        (pany int)
        (** this is for binding a value to a name **)
        (pvar string int)
        (** matching a primitive literal **)
        (pprim prim int)
        (** strings in pattern-matching don't support templates ${} at the moment, but it could be cool to support that at some point. "Hello ${name}" would then match any string with the prefix "Hello ", and bind the rest to the name name. **)
        (pstr string int)
        (** this is how we match algebraic data types.
        for example, (pcon "," [(pvar "a") (pvar "b")]) for the pattern (, a b) **)
        (pcon string (list pat) int))

(** ## Types
    Given that our language is fully inferred (and we don't actually support putting manual type annotations on things yet), the only place you'll see types is when defining custom types with deftype or typealias. **)

(deftype type
    (** Type Variable
        tvar represents a type variable, with a name that's autogenerated to be unique. **)
        (tvar string int)
        (** Type Application
        target, arg, like the type (list int) **)
        (tapp type type int)
        (** "Concrete" type
        int or list, etc. **)
        (tcon string int))

(** You'll notice there's no "function type" here. This follows the shortcut that lots of type inference papers make, skipping out on a dedicated "function" type, and instead representing it with a constructor, often called ->.
    So the type (fn [int] string) would be represented as (tapp (tapp (tcon "->") (tcon "int")) (tcon "string")). **)

(** ## Statements **)

(deftype stmt
    (** Defining custom types! We have the name of the type, and then a list of constructors, each with a name and a list of arguments. **)
        (sdeftype string (list (,, string (list type) int)))
        (** e.g. (def x 2). (defn x [a] b) gets parsed as (def x (fn [x] b)) **)
        (sdef string expr)
        (sexpr expr))

(** ## Syntax Sugar **)

(** The tuple constructor , to allow tuples of any length; (, a b c) will be sugar for (, a (, b c)), (, a b c d) will desugar to (, a (, b (, c d))) and so on. This will show up when parsing types, patterns, and expressions.
    This is really handy for when you want to have a couple things grouped together, but don't want to go to the trouble of coming up with a name for a deftype. **)

(** We've also got a simplified "do notation" to allow for "state" and "error handling" in a pure & functional language.
    (let-> [pat init] value) is translated into continuation-passing style with >>= (pronounced "bind"):
    (>>= init (fn [pat] value))
    As a small example, consider the result type (deftype (result good bad) (ok good) (err bad)), similar to the one seen in Rust. If we define bind to be
    (defn >>= [res next]
      (match res
        (ok value) (next value)
        (err e) (err e))
    Then we can use our "do notation" to handle functions that return results, and it will "bail" if ever it encounters an err. Here's an example with some simple parsing:
    (let-> [name     (parse-name data)
            address  (parse-address data)]
      (<- "Hello ${name}, you live at ${address}."))
    parse-name and parse-age both take some input data and return a (result string err-type). If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an err.
    The <- function in this example is pronounced return (or sometimes pure); it is the function that constructs the "happy path". For results, it is trivial (def <- ok).
    If you want to have a value bound in a let-> that isn't already wrapped in a result, you use <- there too. For example (let-> [age (<- 10)] ...). In this simple example, that let-> isn't needed, the above is equivalent to (let [age 10] ...). **)

