(** ## Abstract Syntax Tree **)

(** Once we have our runtime encoding (primitives, functions, and algebraic data types), we need to decide on an Abstract Syntax Tree. Once again we'll keep the list relatively short, with the goal of "the simplest language that's still nice to use". **)

(** Utility Types (list, tuple) **)

(deftype (list a) (nil) (cons a (list a)))

(deftype (, a b) (, a b))

(** A note about ,: We'll be doing a little extra work any time we see the tuple constructor , to allow tuples of any length; (, a b c) will be sugar for (, a (, b c)), (, a b c d) will desugar to (, a (, b (, c d))) and so on. This will show up when parsing types, patterns, and expressions.
    This is really handy for when you want to have a couple things grouped together, but don't want to go to the trouble of coming up with a name for a deftype. **)

(** We're prefixing constructor names (p for prim, e for expr) to prevent name conflicts between the types. Once we implement polymorphic (structural) variants in language version 2, we don't need the crutch. **)

(deftype prim (pint int) (pbool bool))

(deftype expr
    (** the trailing int on each constructor is a unique id **)
        (eprim prim int)
        (** prefix, template-pairs. All strings are template strings in our language :)
        So "Hello ${world}!" would parse into
        (estr "Hello" [(, (evar "world") "!" 1234)]) **)
        (estr string (list (, expr string int)) int)
        (** a variable reference! might be local or global **)
        (evar string int)
        (** args, body , parsed from the form (fn [arg1 arg2] body). **)
        (elambda (list pat) expr int)
        (** target, args **)
        (eapp expr (list expr) int)
        (** bindings, body **)
        (elet (list (, pat expr)) expr int)
        (** target, cases **)
        (ematch expr (list (, pat expr))))

(deftype pat
    (** the "any" pattern is an underscore _ **)
        (pany int)
        (** this is for binding the value to a name **)
        (pvar string int)
        (** matching a primitive literal **)
        (pprim prim int)
        (** strings in pattern-matching don't support templates ${} at the moment, but it could be cool to support that at some point. "Hello ${name}" would then match any string with the prefix "Hello ", and bind the rest to the name name. **)
        (pstr string int)
        (** this is how we match algebraic data types.
        constructor-name, args
        for example, "," [(pvar "a") (pvar "b")] for the pattern (, a b) **)
        (pcon string (list pat) int))

(deftype type
    (** One shortcut that lots of type inference papers make is skipping out on a dedicated "function" type, and instead representing it with a constructor, generally called ->.
        So the type (fn [int] string) would be represented as (tapp (tapp (tcon "->") (tcon "int")) (tcon "string")).
        tvar represents a type variable, with a name that's autogenerated to be unique. **)
        (tvar string int)
        (** target, arg, like the type (list int) **)
        (tapp type type int)
        (** int or list, etc. **)
        (tcon string int))

(deftype stmt
    (** Defining custom types! We have the name of the type, and then a list of constructors, each with a name and a list of arguments. **)
        (sdeftype string (list (,, string (list type) int)))
        (** e.g. (def x 2). (defn x [a] b) gets parsed as (def x (fn [x] b)) **)
        (sdef string expr)
        (sexpr expr))

