(** ## Abstract Syntax Tree **)

(** Once we have our runtime encoding (primitives, functions, and algebraic data types), we need to decide on an Abstract Syntax Tree. Once again we'll keep the list relatively short, with the goal of "the simplest language that's still nice to use". **)

(** Utility Types (list, tuple) **)

(deftype (list a) (nil) (cons a (list a)))

(deftype (, a b) (, a b))

(** ## Sugar **)

(** The tuple constructor , to allow tuples of any length; (, a b c) will be sugar for (, a (, b c)), (, a b c d) will desugar to (, a (, b (, c d))) and so on. This will show up when parsing types, patterns, and expressions.
    This is really handy for when you want to have a couple things grouped together, but don't want to go to the trouble of coming up with a name for a deftype. **)

(** We've also got a simplified "do notation" to allow for "state" and "error handling" in a pure & functional language.
    (let-> [pat init] value) is translated into continuation-passing style with >>= (pronounced "bind"):
    (>>= init (fn [pat] value))
    As a small example, consider the result type (deftype (result good bad) (ok good) (err bad)), similar to the one seen in Rust. If we define bind to be
    (defn >>= [res next]
      (match res
        (ok value) (next value)
        (err e) (err e))
    Then we can use our "do notation" to handle functions that return results, and it will "bail" if ever it encounters an err. Here's an example with some simple parsing:
    (let-> [name     (parse-name data)
            address  (parse-address data)]
      (<- "Hello ${name}, you live at ${address}."))
    parse-name and parse-age both take some input data and return a (result string err-type). If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an err.
    The <- function in this example is pronounced return (or sometimes pure); it is the function that constructs the "happy path". For results, it is trivial (def <- ok).
    If you want to have a value bound in a let-> that isn't already wrapped in a result, you use <- there too. For example (let-> [age (<- 10)] ...). In this simple example, that let-> isn't needed, the above is equivalent to (let [age 10] ...). **)

(** We're prefixing constructor names (p for prim, e for expr) to prevent name conflicts between the types. Once we implement polymorphic (structural) variants in language version 2, we don't need the crutch. **)

(deftype prim (pint int) (pbool bool))

(deftype expr
    (** the trailing int on each constructor is a unique id **)
        (eprim prim int)
        (** prefix, template-pairs. All strings are template strings in our language :)
        So "Hello ${world}!" would parse into
        (estr "Hello" [(, (evar "world") "!" 1234)]) **)
        (estr string (list (, expr string int)) int)
        (** a variable reference! might be local or global **)
        (evar string int)
        (** args, body , parsed from the form (fn [arg1 arg2] body). **)
        (elambda (list pat) expr int)
        (** target, args **)
        (eapp expr (list expr) int)
        (** bindings, body **)
        (elet (list (, pat expr)) expr int)
        (** target, cases **)
        (ematch expr (list (, pat expr))))

(deftype pat
    (** the "any" pattern is an underscore _ **)
        (pany int)
        (** this is for binding the value to a name **)
        (pvar string int)
        (** matching a primitive literal **)
        (pprim prim int)
        (** strings in pattern-matching don't support templates ${} at the moment, but it could be cool to support that at some point. "Hello ${name}" would then match any string with the prefix "Hello ", and bind the rest to the name name. **)
        (pstr string int)
        (** this is how we match algebraic data types.
        constructor-name, args
        for example, "," [(pvar "a") (pvar "b")] for the pattern (, a b) **)
        (pcon string (list pat) int))

(deftype type
    (** One shortcut that lots of type inference papers make is skipping out on a dedicated "function" type, and instead representing it with a constructor, generally called ->.
        So the type (fn [int] string) would be represented as (tapp (tapp (tcon "->") (tcon "int")) (tcon "string")).
        tvar represents a type variable, with a name that's autogenerated to be unique. **)
        (tvar string int)
        (** target, arg, like the type (list int) **)
        (tapp type type int)
        (** int or list, etc. **)
        (tcon string int))

(deftype stmt
    (** Defining custom types! We have the name of the type, and then a list of constructors, each with a name and a list of arguments. **)
        (sdeftype string (list (,, string (list type) int)))
        (** e.g. (def x 2). (defn x [a] b) gets parsed as (def x (fn [x] b)) **)
        (sdef string expr)
        (sexpr expr))

