{"map":{"0":{"type":"rich-text","contents":[{"id":"52022cf8-840d-4d65-9f10-a106de4d173b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Let's build a compiler!","styles":{}}],"children":[]}],"loc":0},"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variables).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2},"-1":{"type":"list","values":[0],"loc":-1}},"root":-1,"meta":{},"history":[{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":1,"idx":0},{"type":"ns-top","idx":1},{"type":"rich-text","idx":0,"sel":"52022cf8-840d-4d65-9f10-a106de4d173b"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":1,"idx":0},{"type":"ns-top","idx":1},{"idx":0,"type":"subtext","at":0}]}],"prev":{"0":{"type":"blank","loc":0}},"meta":{},"metaPrev":{},"map":{"0":{"type":"rich-text","contents":[{"id":"52022cf8-840d-4d65-9f10-a106de4d173b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Let's build a compiler!","styles":{}}],"children":[]}],"loc":0}},"nsMap":{},"nsPrev":{},"id":0,"ts":1714757469.363,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"91b090fd-fe50-42b8-b9a3-d40413285da9"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":1,"idx":0},{"type":"ns-top","idx":1},{"type":"rich-text","idx":0,"sel":"52022cf8-840d-4d65-9f10-a106de4d173b"}]}],"prev":{"2":null},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add a basic \"do notation\" (via a syntax-only transform)  which will make tracking state in an immutable way much nicer, and we'll be able to do error tracking without resorting to a ","styles":{}},{"type":"text","text":"panic","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{"0":{"id":0,"top":-1,"children":[1,3],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3}},"nsPrev":{"0":{"id":0,"top":-1,"children":[1],"type":"normal"},"3":null},"id":1,"ts":1714757516.081,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"idx":2,"type":"end"}]}],"prev":{"4":null},"meta":{},"metaPrev":{},"map":{"4":{"type":"blank","loc":4}},"nsMap":{"0":{"id":0,"top":-1,"children":[1,3,5],"type":"normal"},"5":{"type":"normal","top":4,"children":[],"id":5}},"nsPrev":{"0":{"id":0,"top":-1,"children":[1,3],"type":"normal"},"5":null},"id":2,"ts":1714768510.952,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prev":{"4":{"type":"blank","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"nsMap":{},"nsPrev":{},"id":3,"ts":1714768513.748,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"nsMap":{},"nsPrev":{},"id":4,"ts":1714768515.23,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"nsMap":{},"nsPrev":{},"id":5,"ts":1714768515.557,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"nsMap":{},"nsPrev":{},"id":6,"ts":1714768515.648,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"nsMap":{},"nsPrev":{},"id":7,"ts":1714768515.799,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"nsMap":{},"nsPrev":{},"id":8,"ts":1714768515.987,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello f","loc":4}},"nsMap":{},"nsPrev":{},"id":9,"ts":1714768516.492,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello f","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello fo","loc":4}},"nsMap":{},"nsPrev":{},"id":10,"ts":1714768516.601,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello fo","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folk","loc":4}},"nsMap":{},"nsPrev":{},"id":11,"ts":1714768516.823,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folk","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folks","loc":4}},"nsMap":{},"nsPrev":{},"id":12,"ts":1714768517.092,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folks","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folks.","loc":4}},"nsMap":{},"nsPrev":{},"id":13,"ts":1714768517.394,"libraryRoot":""},{"id":14,"meta":{},"metaPrev":{},"revert":13,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folks.","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folks","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768519.83,"libraryRoot":""},{"id":15,"meta":{},"metaPrev":{},"revert":12,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folks","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folk","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768520.981,"libraryRoot":""},{"id":16,"meta":{},"metaPrev":{},"revert":11,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello folk","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello fo","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768521.648,"libraryRoot":""},{"id":17,"meta":{},"metaPrev":{},"revert":10,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello fo","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello f","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768522.234,"libraryRoot":""},{"id":18,"meta":{},"metaPrev":{},"revert":9,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello f","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768544.051,"libraryRoot":""},{"id":19,"meta":{},"metaPrev":{},"revert":8,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768544.761,"libraryRoot":""},{"id":20,"meta":{},"metaPrev":{},"revert":7,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768545.306,"libraryRoot":""},{"id":21,"meta":{},"metaPrev":{},"revert":6,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768585.845,"libraryRoot":""},{"id":22,"meta":{},"metaPrev":{},"revert":5,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768586.23,"libraryRoot":""},{"id":23,"meta":{},"metaPrev":{},"revert":4,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768586.634,"libraryRoot":""},{"id":24,"meta":{},"metaPrev":{},"revert":3,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"map":{"4":{"type":"blank","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768587.562,"libraryRoot":""},{"id":25,"meta":{},"metaPrev":{},"revert":24,"prev":{"4":{"type":"blank","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"nsMap":{},"nsPrev":{},"ts":1714768587.8,"libraryRoot":""},{"id":26,"meta":{},"metaPrev":{},"revert":25,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"map":{"4":{"type":"blank","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768589.464,"libraryRoot":""},{"id":27,"meta":{},"metaPrev":{},"revert":26,"prev":{"4":{"type":"blank","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"nsMap":{},"nsPrev":{},"ts":1714768599.433,"libraryRoot":""},{"id":28,"meta":{},"metaPrev":{},"revert":23,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768600.919,"libraryRoot":""},{"id":29,"meta":{},"metaPrev":{},"revert":22,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768601.27,"libraryRoot":""},{"id":30,"meta":{},"metaPrev":{},"revert":29,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768601.768,"libraryRoot":""},{"id":31,"meta":{},"metaPrev":{},"revert":28,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768602.506,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"subtext","at":0}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"nsMap":{},"nsPrev":{},"id":32,"ts":1714768604.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"nsMap":{},"nsPrev":{},"id":33,"ts":1714768609.331,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"nsMap":{},"nsPrev":{},"id":34,"ts":1714768609.47,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"nsMap":{},"nsPrev":{},"id":35,"ts":1714768609.521,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"nsMap":{},"nsPrev":{},"id":36,"ts":1714768609.677,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"nsMap":{},"nsPrev":{},"id":37,"ts":1714768609.838,"libraryRoot":""},{"id":38,"meta":{},"metaPrev":{},"revert":37,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768610.013,"libraryRoot":""},{"id":39,"meta":{},"metaPrev":{},"revert":36,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768610.184,"libraryRoot":""},{"id":40,"meta":{},"metaPrev":{},"revert":35,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768610.328,"libraryRoot":""},{"id":41,"meta":{},"metaPrev":{},"revert":34,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768610.422,"libraryRoot":""},{"id":42,"meta":{},"metaPrev":{},"revert":33,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768610.542,"libraryRoot":""},{"id":43,"meta":{},"metaPrev":{},"revert":42,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768611.155,"libraryRoot":""},{"id":44,"meta":{},"metaPrev":{},"revert":41,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768611.286,"libraryRoot":""},{"id":45,"meta":{},"metaPrev":{},"revert":40,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"he","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768611.469,"libraryRoot":""},{"id":46,"meta":{},"metaPrev":{},"revert":39,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hel","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768611.582,"libraryRoot":""},{"id":47,"meta":{},"metaPrev":{},"revert":38,"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hell","loc":4}},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714768611.698,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h  ello","loc":4}},"nsMap":{},"nsPrev":{},"id":48,"ts":1714770652.634,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h  ello","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"h ello","loc":4}},"nsMap":{},"nsPrev":{},"id":49,"ts":1714770653.463,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"type":"rich-text","idx":4,"sel":null}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"h ello","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"nsMap":{},"nsPrev":{},"id":50,"ts":1714770653.63,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"end"}]}],"prev":{"4":{"type":"raw-code","lang":"javascript","raw":"hello","loc":4}},"meta":{},"metaPrev":{},"map":{"4":{"type":"blank","loc":4}},"nsMap":{"5":{"type":"normal","top":4,"children":[],"id":5}},"nsPrev":{"5":{"type":"normal","top":4,"children":[],"id":5}},"id":51,"ts":1714770654.613,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"idx":2,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prev":{"4":{"type":"blank","loc":4}},"meta":{},"metaPrev":{},"map":{"4":null},"nsMap":{"0":{"id":0,"top":-1,"children":[1,3],"type":"normal"},"5":null},"nsPrev":{"0":{"id":0,"top":-1,"children":[1,3,5],"type":"normal"},"5":{"type":"normal","top":4,"children":[],"id":5}},"id":52,"ts":1714770655.221,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add a basic \"do notation\" (via a syntax-only transform)  which will make tracking state in an immutable way much nicer, and we'll be able to do error tracking without resorting to a ","styles":{}},{"type":"text","text":"panic","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! W","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":53,"ts":1715141016.802,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! W","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":54,"ts":1715141016.943,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":55,"ts":1715141017.066,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'l","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":56,"ts":1715141017.26,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'l","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":57,"ts":1715141017.393,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":58,"ts":1715141017.492,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":59,"ts":1715141017.709,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll ad","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":60,"ts":1715141017.894,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll ad","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":61,"ts":1715141018.024,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":62,"ts":1715141018.147,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add i","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":63,"ts":1715141018.633,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add i","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":64,"ts":1715141018.685,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":65,"ts":1715141018.793,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":66,"ts":1715141019.822,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"h","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":67,"ts":1715141020.071,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"h","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"ho","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":68,"ts":1715141020.106,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"ho","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hov","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":69,"ts":1715141020.189,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hov","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hove","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":70,"ts":1715141020.192,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hove","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":71,"ts":1715141020.254,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":72,"ts":1715141020.385,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover f","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":73,"ts":1715141020.63,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover f","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover fo","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":74,"ts":1715141020.715,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover fo","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":75,"ts":1715141020.788,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":76,"ts":1715141020.881,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":77,"ts":1715141020.977,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for ty","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":78,"ts":1715141021.125,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for ty","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for typ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":79,"ts":1715141021.179,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for typ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":80,"ts":1715141021.263,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":81,"ts":1715141021.457,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\",","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":82,"ts":1715141021.642,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\",","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":83,"ts":1715141021.794,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", m","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":84,"ts":1715141026.158,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", m","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", mu","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":85,"ts":1715141026.381,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", mu","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", muc","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":86,"ts":1715141026.509,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", muc","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":87,"ts":1715141026.614,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":88,"ts":1715141026.746,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much n","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":89,"ts":1715141026.863,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much n","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much ni","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":90,"ts":1715141026.929,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much ni","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nic","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":91,"ts":1715141027.046,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nic","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nice","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":92,"ts":1715141027.138,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nice","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":93,"ts":1715141027.19,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":94,"ts":1715141027.351,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer e","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":95,"ts":1715141027.519,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer e","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer er","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":96,"ts":1715141027.731,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer er","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer err","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":97,"ts":1715141027.878,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer err","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer erro","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":98,"ts":1715141027.961,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer erro","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":99,"ts":1715141028.02,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":100,"ts":1715141028.18,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error r","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":101,"ts":1715141029.121,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error r","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error re","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":102,"ts":1715141029.173,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error re","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error rep","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":103,"ts":1715141029.275,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error rep","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error repo","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":104,"ts":1715141029.338,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error repo","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error repor","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":105,"ts":1715141029.437,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error repor","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error report","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":106,"ts":1715141029.473,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error report","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporti","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":107,"ts":1715141029.606,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporti","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reportin","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":108,"ts":1715141029.661,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reportin","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":109,"ts":1715141029.792,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":110,"ts":1715141030.001,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":111,"ts":1715141032.221,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":112,"ts":1715141032.334,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":113,"ts":1715141032.384,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at p","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":114,"ts":1715141032.467,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at p","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at pa","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":115,"ts":1715141032.547,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at pa","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at par","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":116,"ts":1715141032.723,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at par","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at pars","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":117,"ts":1715141032.87,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at pars","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":118,"ts":1715141032.943,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":119,"ts":1715141033.144,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":120,"ts":1715141033.401,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-ty","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":121,"ts":1715141033.489,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-ty","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-typ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":122,"ts":1715141033.572,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-typ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":123,"ts":1715141033.6,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":124,"ts":1715141033.678,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":125,"ts":1715141033.81,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type an","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":126,"ts":1715141033.898,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type an","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type and","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":127,"ts":1715141033.972,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type and","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type and ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":128,"ts":1715141034.061,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type and ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type and","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":129,"ts":1715141035.271,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type and","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type an","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":130,"ts":1715141035.517,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type an","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":131,"ts":1715141035.551,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":132,"ts":1715141035.585,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":133,"ts":1715141035.616,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-type","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-typ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":134,"ts":1715141035.654,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-typ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-ty","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":135,"ts":1715141035.688,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-ty","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":136,"ts":1715141035.722,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":137,"ts":1715141035.757,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse-","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":138,"ts":1715141035.789,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at parse","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at pars","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":139,"ts":1715141035.82,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at pars","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at par","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":140,"ts":1715141035.854,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at par","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at pa","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":141,"ts":1715141035.887,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at pa","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at p","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":142,"ts":1715141035.92,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at p","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":143,"ts":1715141036.096,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":144,"ts":1715141036.289,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting at","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":145,"ts":1715141036.449,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":146,"ts":1715141036.58,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":147,"ts":1715141036.754,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":148,"ts":1715141036.821,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":149,"ts":1715141036.87,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":150,"ts":1715141036.92,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to th","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":151,"ts":1715141037.026,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to th","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":152,"ts":1715141037.09,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":153,"ts":1715141037.166,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the p","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":154,"ts":1715141037.403,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the p","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the pr","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":155,"ts":1715141037.627,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the pr","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the p","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":156,"ts":1715141037.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the p","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the pa","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":157,"ts":1715141037.972,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the pa","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the par","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":158,"ts":1715141038.253,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the par","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the pars","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":159,"ts":1715141038.414,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the pars","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parse","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":160,"ts":1715141038.496,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parse","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parse ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":161,"ts":1715141038.653,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parse ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parse","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":162,"ts":1715141039.119,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parse","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":163,"ts":1715141039.204,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":164,"ts":1715141039.284,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":165,"ts":1715141039.376,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser an","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":166,"ts":1715141039.531,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser an","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":167,"ts":1715141039.571,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":168,"ts":1715141039.635,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":169,"ts":1715141039.849,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and t","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and ty","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":170,"ts":1715141039.99,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and ty","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and typ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":171,"ts":1715141040.035,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and typ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":172,"ts":1715141040.109,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":173,"ts":1715141040.667,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type c","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":174,"ts":1715141040.874,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type c","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type ch","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":175,"ts":1715141040.922,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type ch","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type chc","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":176,"ts":1715141041.036,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type chc","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type chck","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":177,"ts":1715141041.186,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type chck","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type chc","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":178,"ts":1715141041.45,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type chc","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type ch","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":179,"ts":1715141041.574,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type ch","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type che","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":180,"ts":1715141041.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type che","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type chec","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":181,"ts":1715141041.731,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type chec","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type check","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":182,"ts":1715141041.822,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type check","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checke","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":183,"ts":1715141041.979,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checke","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":184,"ts":1715141042.031,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker,","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":185,"ts":1715141050.646,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker,","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":186,"ts":1715141050.941,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":187,"ts":1715141051.085,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":188,"ts":1715141051.172,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":189,"ts":1715141051.291,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as w","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":190,"ts":1715141051.392,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as w","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as we","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":191,"ts":1715141051.426,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as we","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as wel","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":192,"ts":1715141051.529,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as wel","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":193,"ts":1715141051.677,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":194,"ts":1715141051.687,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":195,"ts":1715141051.863,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":196,"ts":1715141051.928,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":197,"ts":1715141052.03,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as u","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":198,"ts":1715141057.709,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as u","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as us","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":199,"ts":1715141057.821,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as us","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usa","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":200,"ts":1715141057.91,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usa","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usag","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":201,"ts":1715141058.047,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usag","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":202,"ts":1715141058.103,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":203,"ts":1715141058.243,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage r","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":204,"ts":1715141058.446,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage r","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage re","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":205,"ts":1715141058.479,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage re","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage rep","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":206,"ts":1715141058.597,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage rep","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage repo","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":207,"ts":1715141058.65,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage repo","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage repor","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":208,"ts":1715141058.739,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage repor","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage report","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":209,"ts":1715141058.802,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage report","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporti","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":210,"ts":1715141058.889,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporti","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reportin","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":211,"ts":1715141058.94,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reportin","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":212,"ts":1715141059.035,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":213,"ts":1715141059.108,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":214,"ts":1715141059.632,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (f","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":215,"ts":1715141059.86,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (f","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (fo","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":216,"ts":1715141059.952,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (fo","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":217,"ts":1715141060.019,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":218,"ts":1715141060.116,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":219,"ts":1715141060.232,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"f","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":220,"ts":1715141060.446,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"f","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"fi","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":221,"ts":1715141060.537,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"fi","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"fin","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":222,"ts":1715141060.572,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"fin","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":223,"ts":1715141060.634,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":224,"ts":1715141060.736,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":225,"ts":1715141060.822,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find al","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":226,"ts":1715141060.915,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find al","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":227,"ts":1715141061.039,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":228,"ts":1715141061.106,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all r","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":229,"ts":1715141061.307,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all r","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all re","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":230,"ts":1715141061.35,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all re","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all ref","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":231,"ts":1715141061.746,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all ref","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refr","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":232,"ts":1715141061.99,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refr","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refre","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":233,"ts":1715141062.099,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refre","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refr","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":234,"ts":1715141062.667,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refr","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all ref","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":235,"ts":1715141062.835,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all ref","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refe","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":236,"ts":1715141062.91,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refe","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refer","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":237,"ts":1715141062.923,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refer","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refere","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":238,"ts":1715141063.031,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all refere","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all referen","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":239,"ts":1715141063.164,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all referen","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all referenc","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":240,"ts":1715141063.268,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all referenc","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all reference","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":241,"ts":1715141063.289,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all reference","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":242,"ts":1715141063.361,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":243,"ts":1715141063.739,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":244,"ts":1715141063.903,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":245,"ts":1715141064.056,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" a","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" an","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":246,"ts":1715141064.212,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" an","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":247,"ts":1715141064.285,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":248,"ts":1715141064.382,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":249,"ts":1715141064.468,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"b","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":250,"ts":1715141064.795,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"b","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bu","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":251,"ts":1715141064.874,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bu","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bul","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":252,"ts":1715141065.179,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bul","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":253,"ts":1715141065.248,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":254,"ts":1715141065.398,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk ","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk r","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":255,"ts":1715141065.528,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk r","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk re","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":256,"ts":1715141065.604,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk re","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk ren","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":257,"ts":1715141065.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk ren","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rena","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":258,"ts":1715141065.814,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rena","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk renam","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":259,"ts":1715141065.915,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk renam","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rename","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":260,"ts":1715141065.999,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rename","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rename\"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":261,"ts":1715141066.157,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rename\"","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rename\")","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":262,"ts":1715141066.346,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rename\")","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rename\").","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":263,"ts":1715141067.091,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and \"bulk rename\").","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and h).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":264,"ts":1715141071.843,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and h).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and hi).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":265,"ts":1715141071.902,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and hi).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and hig).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":266,"ts":1715141072.061,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and hig).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and high).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":267,"ts":1715141072.111,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and high).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highl).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":268,"ts":1715141072.233,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highl).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highli).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":269,"ts":1715141072.291,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highli).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlih).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":270,"ts":1715141072.368,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlih).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlihg).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":271,"ts":1715141072.393,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlihg).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlih).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":272,"ts":1715141073.021,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlih).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highli).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":273,"ts":1715141073.151,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highli).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlig).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":274,"ts":1715141073.346,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlig).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highligh).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":275,"ts":1715141073.42,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highligh).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlight).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":276,"ts":1715141074.137,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlight).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighti).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":277,"ts":1715141074.253,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighti).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlightin).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":278,"ts":1715141074.284,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlightin).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":279,"ts":1715141074.496,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting ).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":280,"ts":1715141074.659,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting ).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting u).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":281,"ts":1715141074.764,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting u).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting un).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":282,"ts":1715141074.822,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting un).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unu).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":283,"ts":1715141074.933,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unu).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unus).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":284,"ts":1715141075.048,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unus).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unuse).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":285,"ts":1715141075.123,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unuse).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":286,"ts":1715141075.324,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused ).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":287,"ts":1715141075.452,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused ).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused v).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":288,"ts":1715141077.711,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused v).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused va).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":289,"ts":1715141077.868,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused va).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused var).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":290,"ts":1715141078.012,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused var).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused vari).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":291,"ts":1715141078.16,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused vari).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused varia).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":292,"ts":1715141078.24,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused varia).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variab).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":293,"ts":1715141078.413,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variab).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variabl).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":294,"ts":1715141078.504,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variabl).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variable).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":295,"ts":1715141078.589,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variable).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variables).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":296,"ts":1715141078.651,"libraryRoot":""}],"clipboard":[],"hover":[],"regs":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"926e5b16-68a3-456d-9ce1-21a4b394a8e0"}]}],"cards":[{"path":[],"top":0}],"nsMap":{"0":{"id":0,"top":-1,"children":[1,3],"type":"normal"},"1":{"id":1,"top":0,"children":[],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3}},"highlight":[]}