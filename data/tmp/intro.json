{"map":{"0":{"type":"rich-text","contents":[{"id":"52022cf8-840d-4d65-9f10-a106de4d173b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Let's build a compiler!","styles":{}}],"children":[]}],"loc":0},"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a lightly extended implementation of \"Algorithm W\" (adding in pattern matching and custom data types).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variables).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]}],"loc":2},"4":{"type":"rich-text","contents":[{"id":"4c424dd7-ccb0-423e-b662-bdb297e884e7","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"What will we be building?","styles":{}}],"children":[]}],"loc":4},"6":{"type":"rich-text","contents":[{"id":"7cbc94ce-46aa-4704-94bf-fff3ac5d7c38","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"How is this different from other compiler tutorials?","styles":{}}],"children":[]}],"loc":6},"8":{"type":"rich-text","contents":[{"id":"b47074f6-3042-40aa-88fa-7f8990d1c171","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"How to use this series:","styles":{}}],"children":[]}],"loc":8},"10":{"type":"rich-text","contents":[{"id":"df38dc65-7fc2-4224-b737-5b63eaf15bc3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are several different ways you could use this tutorial series:","styles":{}}],"children":[]},{"id":"055741c6-6106-44bd-9a1e-4f9d9cde329d","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Just read it. Go through all the code and fixture tests, reading closely to understand each part. Edit the \"inputs\" in the fixture tests and see what the \"outputs\" change to.","styles":{}}],"children":[]},{"id":"95bbc03f-c971-4fb0-b16b-7febf2d26aef","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Read it & reproduce it. Have the \"Playground\" document open side-by-side with each document as you progress through the tutorial, and reproduce each function and type definition, experimenting with inputs & outputs. Once you feel confident about how things work, you could even put your own spin on things :)","styles":{}}],"children":[]},{"id":"d7fc4adc-93db-46b6-9d24-fe3cf3cebc90","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Reproduce it in a different programming language! Just because this implementation is self-hosting, doesn't mean yours has to be. Translate each function from this language into one of your choice; JavaScript or Elm, Go or Rust. You can use the embedded fixture tests to check your implementation and verify that everything is working as expected.","styles":{}}],"children":[]},{"id":"b418bd33-469d-40cc-a5fe-ff530b627bf3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"If you really want to go for deep understanding, maybe try all three :)","styles":{}}],"children":[]}],"loc":10},"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive, that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12},"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured editor.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14},"16":{"type":"rich-text","contents":[{"id":"42631239-3fc2-4f99-a4a5-8a886e89ad57","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"An Overview of the process:","styles":{}}],"children":[]}],"loc":16},"-1":{"type":"list","values":[0],"loc":-1}},"root":-1,"meta":{},"history":[{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fie","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fi","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6433,"ts":1715570234.327,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fi","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fix","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6434,"ts":1715570234.427,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fix","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixe","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6435,"ts":1715570234.574,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixe","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6436,"ts":1715570234.697,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6437,"ts":1715570234.784,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and it also makes the structured editor much more tractable.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and m","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6438,"ts":1715570276.008,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and m","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and ma","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6439,"ts":1715570276.082,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and ma","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and mak","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6440,"ts":1715570276.199,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and mak","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and make","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6441,"ts":1715570276.283,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and make","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and make ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6442,"ts":1715570276.501,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and make ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and make","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6443,"ts":1715570276.765,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and make","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6444,"ts":1715570276.847,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6445,"ts":1715570276.934,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6446,"ts":1715570277.005,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes th","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6447,"ts":1715570277.065,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes th","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6448,"ts":1715570277.18,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6449,"ts":1715570277.241,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the m","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6450,"ts":1715570277.325,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the m","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the ma","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6451,"ts":1715570277.429,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the ma","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the map","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6452,"ts":1715570277.536,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the map","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapp","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6453,"ts":1715570277.648,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapp","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mappi","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6454,"ts":1715570277.775,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mappi","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mappin","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6455,"ts":1715570277.827,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mappin","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6456,"ts":1715570277.887,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6457,"ts":1715570277.98,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping o","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6458,"ts":1715570278.043,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping o","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping ob","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6459,"ts":1715570278.736,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping ob","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obv","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6460,"ts":1715570278.934,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obv","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvi","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6461,"ts":1715570279.004,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvi","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvio","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6462,"ts":1715570279.203,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvio","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obviou","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6463,"ts":1715570279.254,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obviou","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6464,"ts":1715570279.361,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6465,"ts":1715570279.486,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious b","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6466,"ts":1715570279.92,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious b","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious be","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6467,"ts":1715570279.998,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious be","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious bet","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6468,"ts":1715570280.087,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious bet","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious betw","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6469,"ts":1715570280.241,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious betw","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious betwe","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6470,"ts":1715570280.402,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious betwe","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious betwee","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6471,"ts":1715570280.539,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious betwee","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6472,"ts":1715570280.593,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6473,"ts":1715570280.691,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6474,"ts":1715570280.771,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between th","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6475,"ts":1715570280.879,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between th","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6476,"ts":1715570280.998,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6477,"ts":1715570281.055,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the s","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6478,"ts":1715570283.283,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the s","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the sy","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6479,"ts":1715570283.383,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the sy","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syn","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6480,"ts":1715570283.535,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syn","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the synt","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6481,"ts":1715570283.577,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the synt","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntx","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6482,"ts":1715570283.846,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntx","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the synt","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6483,"ts":1715570284.233,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the synt","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the synta","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6484,"ts":1715570284.567,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the synta","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6485,"ts":1715570284.737,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6486,"ts":1715570284.912,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax a","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6487,"ts":1715570285.046,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax a","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax an","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6488,"ts":1715570285.105,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax an","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6489,"ts":1715570285.233,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6490,"ts":1715570285.283,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6491,"ts":1715570285.388,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and th","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6492,"ts":1715570285.453,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and th","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6493,"ts":1715570285.533,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6494,"ts":1715570285.671,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the s","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6495,"ts":1715570289.834,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the s","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the st","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6496,"ts":1715570289.952,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the st","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the str","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6497,"ts":1715570289.98,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the str","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the stru","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6498,"ts":1715570290.084,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the stru","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the struc","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6499,"ts":1715570290.207,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the struc","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the struct","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6500,"ts":1715570290.351,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the struct","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structu","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6501,"ts":1715570290.43,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structu","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structur","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6502,"ts":1715570290.518,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structur","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6503,"ts":1715570290.567,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure,","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6504,"ts":1715570290.679,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure,","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6505,"ts":1715570290.775,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, w","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6506,"ts":1715570291.305,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, w","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, wh","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6507,"ts":1715570291.373,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, wh","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, whi","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6508,"ts":1715570291.419,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, whi","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, whic","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6509,"ts":1715570291.67,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, whic","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6510,"ts":1715570291.967,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6511,"ts":1715570292.139,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which w","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6512,"ts":1715570292.26,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which w","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6513,"ts":1715570292.307,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6514,"ts":1715570292.4,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'l","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6515,"ts":1715570292.571,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'l","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6516,"ts":1715570292.707,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6517,"ts":1715570292.83,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6518,"ts":1715570292.901,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll ta","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6519,"ts":1715570293.01,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll ta","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll tak","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6520,"ts":1715570293.102,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll tak","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6521,"ts":1715570293.176,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6522,"ts":1715570293.284,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take a","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6523,"ts":1715570293.356,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take a","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take ad","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6524,"ts":1715570293.717,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take ad","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take adv","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6525,"ts":1715570293.926,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take adv","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take adva","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6526,"ts":1715570294.069,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take adva","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advan","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6527,"ts":1715570294.167,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advan","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advant","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6528,"ts":1715570294.251,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advant","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advanta","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6529,"ts":1715570294.31,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advanta","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantag","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6530,"ts":1715570294.44,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantag","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6531,"ts":1715570294.519,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6532,"ts":1715570294.604,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage o","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6533,"ts":1715570294.643,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage o","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6534,"ts":1715570294.741,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6535,"ts":1715570294.833,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of i","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6536,"ts":1715570294.959,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of i","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6537,"ts":1715570295.005,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6538,"ts":1715570295.085,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6539,"ts":1715570295.177,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in t","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in th","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6540,"ts":1715570295.246,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in th","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6541,"ts":1715570295.347,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6542,"ts":1715570295.442,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the s","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6543,"ts":1715570295.873,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the s","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the st","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6544,"ts":1715570295.894,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the st","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the str","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6545,"ts":1715570295.938,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the str","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the stru","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6546,"ts":1715570296.01,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the stru","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the struc","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6547,"ts":1715570296.097,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the struc","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the struct","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6548,"ts":1715570296.219,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the struct","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structu","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6549,"ts":1715570296.321,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structu","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structur","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6550,"ts":1715570296.38,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structur","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structure","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6551,"ts":1715570296.425,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structure","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6552,"ts":1715570296.564,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6553,"ts":1715570296.659,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured ","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured e","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6554,"ts":1715570296.732,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured e","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured ed","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6555,"ts":1715570296.883,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured ed","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured edi","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6556,"ts":1715570296.975,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured edi","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured edit","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6557,"ts":1715570297.092,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured edit","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured edito","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6558,"ts":1715570297.181,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured edito","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured editor","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6559,"ts":1715570297.265,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"8d290f20-39ac-4477-96f5-2c268c672fe0"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured editor","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured editor.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6560,"ts":1715570298.471,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6561,"ts":1715570443.708,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"T","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6562,"ts":1715570447.466,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"T","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6563,"ts":1715570447.537,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Thi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6564,"ts":1715570447.582,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Thi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6565,"ts":1715570447.675,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6566,"ts":1715570447.747,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6567,"ts":1715570447.884,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This al","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6568,"ts":1715570447.916,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This al","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This als","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6569,"ts":1715570448.043,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This als","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6570,"ts":1715570448.1,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6571,"ts":1715570448.251,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also m","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6572,"ts":1715570448.373,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also m","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also me","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6573,"ts":1715570448.468,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also me","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also mea","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6574,"ts":1715570448.559,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also mea","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also mean","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6575,"ts":1715570448.735,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also mean","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6576,"ts":1715570448.897,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6577,"ts":1715570449.025,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6578,"ts":1715570449.08,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6579,"ts":1715570449.192,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means tha","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6580,"ts":1715570449.24,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means tha","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6581,"ts":1715570449.292,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6582,"ts":1715570449.364,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6583,"ts":1715570455.488,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6584,"ts":1715570455.541,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6585,"ts":1715570455.634,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6586,"ts":1715570455.707,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6587,"ts":1715570455.77,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the la","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6588,"ts":1715570455.859,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the la","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the lan","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6589,"ts":1715570455.962,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the lan","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the lang","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6590,"ts":1715570456.059,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the lang","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the langu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6591,"ts":1715570456.139,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the langu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the langua","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6592,"ts":1715570456.219,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the langua","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the languag","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6593,"ts":1715570456.287,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the languag","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6594,"ts":1715570456.343,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6595,"ts":1715570456.442,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6596,"ts":1715570456.569,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6597,"ts":1715570456.618,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6598,"ts":1715570456.714,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6599,"ts":1715570456.959,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6600,"ts":1715570457.073,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6601,"ts":1715570457.186,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6602,"ts":1715570457.279,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6603,"ts":1715570457.349,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6604,"ts":1715570457.446,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be u","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6605,"ts":1715570457.61,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be u","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be us","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6606,"ts":1715570459.661,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be us","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be usi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6607,"ts":1715570459.797,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be usi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be usin","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6608,"ts":1715570459.817,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be usin","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6609,"ts":1715570459.881,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6610,"ts":1715570459.978,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6611,"ts":1715570460.123,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6612,"ts":1715570460.208,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6613,"ts":1715570460.32,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6614,"ts":1715570460.501,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is to","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6615,"ts":1715570460.564,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is to","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is tot","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6616,"ts":1715570460.625,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is tot","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totl","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6617,"ts":1715570460.827,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totl","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totll","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6618,"ts":1715570460.965,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totll","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totl","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6619,"ts":1715570461.185,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totl","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is tot","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6620,"ts":1715570461.317,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is tot","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is tota","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6621,"ts":1715570461.384,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is tota","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is total","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6622,"ts":1715570461.533,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is total","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totall","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6623,"ts":1715570461.669,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totall","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6624,"ts":1715570461.804,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6625,"ts":1715570462.118,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally n","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6626,"ts":1715570462.427,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally n","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally ne","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6627,"ts":1715570462.547,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally ne","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6628,"ts":1715570462.587,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new!","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6629,"ts":1715570462.907,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new!","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6630,"ts":1715570463.157,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! I","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6631,"ts":1715570471.747,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! I","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6632,"ts":1715570471.88,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6633,"ts":1715570471.957,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If y","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6634,"ts":1715570472.059,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If y","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If yo","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6635,"ts":1715570472.188,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If yo","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6636,"ts":1715570472.235,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6637,"ts":1715570472.299,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6638,"ts":1715570472.526,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you al","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6639,"ts":1715570472.583,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you al","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you alr","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6640,"ts":1715570472.711,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you alr","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you alre","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6641,"ts":1715570472.75,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you alre","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you alrea","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6642,"ts":1715570472.822,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you alrea","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you alread","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6643,"ts":1715570472.902,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you alread","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6644,"ts":1715570472.969,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6645,"ts":1715570473.092,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already k","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6646,"ts":1715570473.586,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already k","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already kn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6647,"ts":1715570473.681,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already kn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already kno","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6648,"ts":1715570473.816,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already kno","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6649,"ts":1715570473.889,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6650,"ts":1715570473.973,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6651,"ts":1715570474.297,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know se","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6652,"ts":1715570474.53,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know se","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know sev","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6653,"ts":1715570474.625,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know sev","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know seve","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6654,"ts":1715570474.751,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know seve","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know sever","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6655,"ts":1715570474.866,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know sever","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know severa","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6656,"ts":1715570474.997,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know severa","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6657,"ts":1715570475.05,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6658,"ts":1715570475.123,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several d","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6659,"ts":1715570475.231,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several d","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several di","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6660,"ts":1715570475.337,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several di","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several dif","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6661,"ts":1715570475.405,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several dif","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several diff","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6662,"ts":1715570475.546,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several diff","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several diffe","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6663,"ts":1715570475.692,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several diffe","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several differ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6664,"ts":1715570475.745,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several differ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several differe","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6665,"ts":1715570475.894,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several differe","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several differen","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6666,"ts":1715570476.105,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several differen","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6667,"ts":1715570476.187,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6668,"ts":1715570476.341,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6669,"ts":1715570476.461,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different la","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6670,"ts":1715570476.65,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different la","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different lan","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6671,"ts":1715570476.766,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different lan","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different lang","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6672,"ts":1715570476.862,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different lang","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different langu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6673,"ts":1715570476.944,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different langu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different langua","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6674,"ts":1715570477,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different langua","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languag","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6675,"ts":1715570477.088,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languag","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6676,"ts":1715570477.116,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6677,"ts":1715570477.318,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language,s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6678,"ts":1715570477.388,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language,s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6679,"ts":1715570477.62,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6680,"ts":1715570477.737,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different language","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6681,"ts":1715570477.85,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6682,"ts":1715570477.959,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6683,"ts":1715570478.031,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6684,"ts":1715570482.855,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, an","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6685,"ts":1715570482.979,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, an","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, ano","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6686,"ts":1715570483.065,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, ano","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, anot","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6687,"ts":1715570483.107,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, anot","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, anoth","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6688,"ts":1715570483.199,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, anoth","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, anothe","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6689,"ts":1715570483.279,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, anothe","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6690,"ts":1715570483.326,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6691,"ts":1715570483.394,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another o","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6692,"ts":1715570483.584,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another o","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another on","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6693,"ts":1715570483.647,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another on","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6694,"ts":1715570483.731,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6695,"ts":1715570483.815,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6696,"ts":1715570483.892,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one is","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6697,"ts":1715570483.988,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one is","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6698,"ts":1715570484.64,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn'","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6699,"ts":1715570484.729,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn'","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6700,"ts":1715570484.831,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6701,"ts":1715570484.936,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6702,"ts":1715570485.036,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't to","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6703,"ts":1715570485.128,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't to","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6704,"ts":1715570485.273,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6705,"ts":1715570485.456,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too h","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6706,"ts":1715570485.59,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too h","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too ha","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6707,"ts":1715570485.659,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too ha","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too har","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6708,"ts":1715570485.739,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too har","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6709,"ts":1715570485.911,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6710,"ts":1715570485.975,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6711,"ts":1715570486.055,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6712,"ts":1715570486.111,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6713,"ts":1715570486.215,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to p","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6714,"ts":1715570486.499,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to p","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pc","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6715,"ts":1715570486.692,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pc","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pck","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6716,"ts":1715570486.779,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pck","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pc","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6717,"ts":1715570487.019,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pc","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to p","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6718,"ts":1715570487.138,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to p","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6719,"ts":1715570487.292,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pic","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6720,"ts":1715570487.418,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pic","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6721,"ts":1715570487.47,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6722,"ts":1715570487.683,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick u","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6723,"ts":1715570487.748,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick u","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6724,"ts":1715570487.823,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6725,"ts":1715570488.006,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6726,"ts":1715570488.079,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6727,"ts":1715570488.278,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, bu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6728,"ts":1715570488.346,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, bu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6729,"ts":1715570488.407,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6730,"ts":1715570488.491,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6731,"ts":1715570488.574,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6732,"ts":1715570488.657,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6733,"ts":1715570488.753,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6734,"ts":1715570488.825,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if it","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6735,"ts":1715570488.938,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if it","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6736,"ts":1715570489.336,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6737,"ts":1715570489.643,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6738,"ts":1715570489.809,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6739,"ts":1715570489.939,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if thi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6740,"ts":1715570489.975,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if thi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if this","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6741,"ts":1715570490.04,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if this","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if this ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6742,"ts":1715570490.164,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if this ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if this","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6743,"ts":1715570493.806,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if this","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if thi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6744,"ts":1715570493.924,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if thi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6745,"ts":1715570494.107,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6746,"ts":1715570494.39,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6747,"ts":1715570494.535,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if y","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6748,"ts":1715570494.879,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if y","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if yo","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6749,"ts":1715570495.066,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if yo","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6750,"ts":1715570495.1,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6751,"ts":1715570495.211,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you k","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6752,"ts":1715570495.342,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you k","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you kn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6753,"ts":1715570495.371,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you kn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you k","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6754,"ts":1715570495.917,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you k","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6755,"ts":1715570496.032,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you o","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6756,"ts":1715570496.265,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you o","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you on","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6757,"ts":1715570496.299,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you on","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you onl","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6758,"ts":1715570496.454,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you onl","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6759,"ts":1715570496.528,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6760,"ts":1715570496.691,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only k","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6761,"ts":1715570496.853,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only k","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only kn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6762,"ts":1715570496.903,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only kn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only kno","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6763,"ts":1715570497.031,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only kno","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6764,"ts":1715570497.115,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6765,"ts":1715570497.191,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know o","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6766,"ts":1715570497.436,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know o","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know on","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6767,"ts":1715570497.499,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know on","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6768,"ts":1715570497.567,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6769,"ts":1715570497.659,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one o","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6770,"ts":1715570497.798,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one o","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6771,"ts":1715570497.935,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6772,"ts":1715570498.608,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6773,"ts":1715570498.816,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or tw","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6774,"ts":1715570498.856,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or tw","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6775,"ts":1715570498.936,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the  language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6776,"ts":1715570502.668,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the  language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the p language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6777,"ts":1715570502.716,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the p language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pr language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6778,"ts":1715570502.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pr language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pri language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6779,"ts":1715570502.949,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pri language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the prir language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6780,"ts":1715570503.102,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the prir language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pri language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6781,"ts":1715570503.494,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pri language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pr language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6782,"ts":1715570503.74,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pr language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pro language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6783,"ts":1715570503.986,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the pro language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the prog language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6784,"ts":1715570504.061,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the prog language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the progr language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6785,"ts":1715570504.086,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the progr language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the progra language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6786,"ts":1715570504.224,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the progra language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the program language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6787,"ts":1715570504.309,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the program language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programm language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6788,"ts":1715570504.432,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programm language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programmi language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6789,"ts":1715570504.547,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programmi language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programmin language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6790,"ts":1715570504.598,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programmin language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6791,"ts":1715570504.647,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6792,"ts":1715570506.947,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6793,"ts":1715570507.099,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6794,"ts":1715570507.19,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, we","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6795,"ts":1715570507.255,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, we","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, wel","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6796,"ts":1715570507.307,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, wel","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welc","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6797,"ts":1715570507.446,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welc","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welco","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6798,"ts":1715570507.534,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welco","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcom","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6799,"ts":1715570507.562,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcom","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6800,"ts":1715570507.631,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome!","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6801,"ts":1715570507.854,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome!","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6802,"ts":1715570507.995,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! T","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6803,"ts":1715570508.125,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! T","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! Th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6804,"ts":1715570508.249,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! Th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! Thi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6805,"ts":1715570508.291,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! Thi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6806,"ts":1715570508.368,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6807,"ts":1715570508.436,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6808,"ts":1715570508.567,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This wi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6809,"ts":1715570508.655,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This wi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This wil","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6810,"ts":1715570508.863,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This wil","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6811,"ts":1715570508.981,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6812,"ts":1715570509.08,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6813,"ts":1715570509.221,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6814,"ts":1715570509.294,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6815,"ts":1715570509.389,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6816,"ts":1715570509.471,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6817,"ts":1715570509.602,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a g","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6818,"ts":1715570518.1,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a g","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a gr","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6819,"ts":1715570518.103,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a gr","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a gre","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6820,"ts":1715570518.179,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a gre","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a grea","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6821,"ts":1715570518.348,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a grea","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6822,"ts":1715570518.456,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6823,"ts":1715570518.562,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6824,"ts":1715570518.725,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great le","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6825,"ts":1715570518.79,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great le","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great lea","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6826,"ts":1715570518.859,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great lea","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great lear","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6827,"ts":1715570518.914,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great lear","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6828,"ts":1715570519.015,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learn","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learni","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6829,"ts":1715570519.156,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learni","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learnin","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6830,"ts":1715570519.203,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learnin","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6831,"ts":1715570519.279,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6832,"ts":1715570519.367,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning e","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6833,"ts":1715570519.456,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning e","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning ex","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6834,"ts":1715570519.633,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning ex","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning exp","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6835,"ts":1715570519.713,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning exp","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning expe","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6836,"ts":1715570519.831,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning expe","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning exper","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6837,"ts":1715570519.887,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning exper","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6838,"ts":1715570519.959,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experie","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6839,"ts":1715570520.075,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experie","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experien","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6840,"ts":1715570520.135,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experien","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experienc","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6841,"ts":1715570520.25,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experienc","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6842,"ts":1715570520.282,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that the programming language we'll be using is totally new! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6843,"ts":1715570524.41,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6844,"ts":1715570528.971,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience,","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6845,"ts":1715570529.064,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6846,"ts":1715570529.314,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, an","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6847,"ts":1715570529.406,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, an","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, and","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6848,"ts":1715570529.485,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, and","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, and ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6849,"ts":1715570529.521,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, and ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, and","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6850,"ts":1715570541.689,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, and","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, an","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6851,"ts":1715570541.934,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, an","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6852,"ts":1715570541.968,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, a","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6853,"ts":1715570542.129,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6854,"ts":1715570542.535,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wt","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6855,"ts":1715570542.694,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wt","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wth","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6856,"ts":1715570542.779,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wth","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wth ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6857,"ts":1715570542.842,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wth ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wth","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6858,"ts":1715570543.454,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wth","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wt","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6859,"ts":1715570543.78,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wt","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6860,"ts":1715570544.014,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, w","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6861,"ts":1715570544.243,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wit","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6862,"ts":1715570544.358,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, wit","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6863,"ts":1715570544.432,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6864,"ts":1715570544.612,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6865,"ts":1715570544.692,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6866,"ts":1715570544.801,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6867,"ts":1715570544.853,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6868,"ts":1715570544.978,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6869,"ts":1715570545.074,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the be","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6870,"ts":1715570545.124,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the be","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the ben","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6871,"ts":1715570545.261,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the ben","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the bene","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6872,"ts":1715570545.368,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the bene","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benef","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6873,"ts":1715570545.91,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benef","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6874,"ts":1715570545.984,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6875,"ts":1715570546.067,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6876,"ts":1715570546.23,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6877,"ts":1715570548.75,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6878,"ts":1715570548.813,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit tha","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6879,"ts":1715570548.894,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit tha","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6880,"ts":1715570548.944,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6881,"ts":1715570549.027,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6882,"ts":1715570549.079,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that t","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6883,"ts":1715570549.148,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that th","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6884,"ts":1715570549.219,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6885,"ts":1715570549.291,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6886,"ts":1715570549.573,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the l","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the la","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6887,"ts":1715570549.657,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the la","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the lan","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6888,"ts":1715570549.767,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the lan","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the lang","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6889,"ts":1715570549.852,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the lang","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the langu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6890,"ts":1715570549.979,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the langu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the langua","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6891,"ts":1715570549.999,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the langua","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the languag","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6892,"ts":1715570550.125,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the languag","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6893,"ts":1715570550.166,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6894,"ts":1715570550.474,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6895,"ts":1715570551.18,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language si","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6896,"ts":1715570551.24,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language si","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6897,"ts":1715570551.499,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6898,"ts":1715570551.618,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6899,"ts":1715570551.826,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language i","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6900,"ts":1715570551.958,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6901,"ts":1715570552.029,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6902,"ts":1715570552.093,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is b","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6903,"ts":1715570552.146,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6904,"ts":1715570552.277,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by n","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6905,"ts":1715570552.427,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by n","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by ne","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6906,"ts":1715570552.506,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by ne","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by nec","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6907,"ts":1715570552.631,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by nec","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by nece","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6908,"ts":1715570552.728,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by nece","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by neces","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6909,"ts":1715570552.97,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by neces","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necess","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6910,"ts":1715570553.083,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necess","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6911,"ts":1715570553.174,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessi","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessit","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6912,"ts":1715570553.282,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessit","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6913,"ts":1715570553.37,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6914,"ts":1715570553.494,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity q","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6915,"ts":1715570554.655,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity q","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity qu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6916,"ts":1715570554.748,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity qu","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity qui","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6917,"ts":1715570555.035,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity qui","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quit","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6918,"ts":1715570555.133,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quit","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6919,"ts":1715570555.193,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6920,"ts":1715570555.296,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite ","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6921,"ts":1715570555.474,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite s","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite si","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6922,"ts":1715570555.582,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite si","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite sim","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6923,"ts":1715570555.644,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite sim","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simp","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6924,"ts":1715570555.819,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simp","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simpl","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6925,"ts":1715570555.861,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simpl","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6926,"ts":1715570556.002,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6927,"ts":1715570556.93,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive -- that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive - that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6928,"ts":1715570579.992,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive - that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive  that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6929,"ts":1715570580.206,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive  that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6930,"ts":1715570580.347,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":7,"idx":0},{"type":"ns","child":13,"idx":7},{"type":"ns-top","idx":13},{"type":"rich-text","idx":12,"sel":"45a383e7-3615-4ae0-a79b-8a102d80ed12"}]}],"prev":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"meta":{},"metaPrev":{},"map":{"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive, that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12}},"nsMap":{},"nsPrev":{},"id":6931,"ts":1715570581.439,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf"}]}],"prev":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling. Also note that we don't yet check match expressions for exhaustiveness ðŸ˜¬ but that will be fixed.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured editor.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured editor.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14}},"nsMap":{},"nsPrev":{},"id":6932,"ts":1715627270.089,"libraryRoot":""}],"clipboard":[],"hover":[],"regs":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf"}]}],"cards":[{"path":[],"top":0}],"nsMap":{"0":{"id":0,"top":-1,"children":[1,5,7,9,17],"type":"normal"},"1":{"id":1,"top":0,"children":[],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3},"5":{"type":"normal","top":4,"children":[15],"id":5,"collapsed":false},"7":{"type":"normal","top":6,"children":[13],"id":7,"collapsed":false},"9":{"type":"normal","top":8,"children":[11],"id":9,"collapsed":false},"11":{"type":"normal","top":10,"children":[],"id":11},"13":{"type":"normal","top":12,"children":[],"id":13},"15":{"type":"normal","top":14,"children":[],"id":15},"17":{"type":"normal","top":16,"children":[3],"id":17,"collapsed":false}},"highlight":[]}