{"map":{"0":{"type":"rich-text","contents":[{"id":"52022cf8-840d-4d65-9f10-a106de4d173b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Let's build a compiler!","styles":{}}],"children":[]}],"loc":0},"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a lightly extended implementation of \"Algorithm W\" (adding in pattern matching and custom data types).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add in \"hover for type\", much nicer error reporting to the parser and type checker, as well as usage reporting (for \"find all references\" and highlighting unused variables).","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]}],"loc":2},"4":{"type":"rich-text","contents":[{"id":"4c424dd7-ccb0-423e-b662-bdb297e884e7","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"What will we be building?","styles":{}}],"children":[]}],"loc":4},"6":{"type":"rich-text","contents":[{"id":"7cbc94ce-46aa-4704-94bf-fff3ac5d7c38","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"How is this different from other compiler tutorials?","styles":{}}],"children":[]}],"loc":6},"8":{"type":"rich-text","contents":[{"id":"b47074f6-3042-40aa-88fa-7f8990d1c171","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"How to use this series:","styles":{}}],"children":[]}],"loc":8},"10":{"type":"rich-text","contents":[{"id":"df38dc65-7fc2-4224-b737-5b63eaf15bc3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are several different ways you could use this tutorial series:","styles":{}}],"children":[]},{"id":"055741c6-6106-44bd-9a1e-4f9d9cde329d","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Just read it. Go through all the code and fixture tests, reading closely to understand each part. Edit the \"inputs\" in the fixture tests and see what the \"outputs\" change to.","styles":{}}],"children":[]},{"id":"95bbc03f-c971-4fb0-b16b-7febf2d26aef","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Read it & reproduce it. Have the \"Playground\" document open side-by-side with each document as you progress through the tutorial, and reproduce each function and type definition, experimenting with inputs & outputs. Once you feel confident about how things work, you could even put your own spin on things :)","styles":{}}],"children":[]},{"id":"d7fc4adc-93db-46b6-9d24-fe3cf3cebc90","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Reproduce it in a different programming language! Just because this implementation is self-hosting, doesn't mean yours has to be. Translate each function from this language into one of your choice; JavaScript or Elm, Go or Rust. You can use the embedded fixture tests to check your implementation and verify that everything is working as expected.","styles":{}}],"children":[]},{"id":"b418bd33-469d-40cc-a5fe-ff530b627bf3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"If you really want to go for deep understanding, maybe try all three :)","styles":{}}],"children":[]}],"loc":10},"12":{"type":"rich-text","contents":[{"id":"45a383e7-3615-4ae0-a79b-8a102d80ed12","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This compiler will be ","styles":{}},{"type":"text","text":"self-hosted","styles":{"bold":true}},{"type":"text","text":" (it will be written in the language that it compiles)! This means a bit more work for us, but it has some really nice benefits; if there's a language feature we wish we had while implementing the compiler, we can just add it! It also means that we'll be \"dogfooding\" almost the whole time: instead of splitting time between \"working on the language\" and \"working in the language\", we'll do both at once!","styles":{}}],"children":[]},{"id":"a97288da-dbd6-4730-94fa-4c7a45b62046","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This also means that ","styles":{}},{"type":"text","text":"the programming language we'll be using is totally new","styles":{"bold":true}},{"type":"text","text":"! If you already know several different languages, another one isn't too hard to pick up, but if you only know one or two, welcome! This will be a great learning experience, with the benefit that the language is by necessity quite simple.","styles":{}}],"children":[]},{"id":"e53e2f0b-79c0-436f-aa47-4646bf1b77fe","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our language will have ","styles":{}},{"type":"text","text":"full type inference","styles":{"bold":true}},{"type":"text","text":". Like elm, haskell, or ocaml, we will have rock-solid type safety, ","styles":{}},{"type":"text","text":"without","styles":{"italic":true}},{"type":"text","text":" having to annotate types everywhere. This is (imo) one of the biggest contributions of this tutorial; there are lots of compiler tutorials out there, but very few ","styles":{}},{"type":"text","text":"type inference algorithm","styles":{"italic":true}},{"type":"text","text":" tutorials, and none that are interactive, that let you play with the inputs and outputs, introspecting every step of the way.","styles":{}}],"children":[]},{"id":"0e7649e8-d719-46f7-bde7-d4c54e65d210","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial is implemented in and through a ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Literate_programming","content":[{"type":"text","text":"literate programming","styles":{}}]},{"type":"text","text":" ","styles":{}},{"type":"link","href":"https://en.wikipedia.org/wiki/Structure_editor","content":[{"type":"text","text":"structured editor environment","styles":{}}]},{"type":"text","text":". This allows us to get rich editor integration (hover for type, inline error reporting), integrated REPL (edit any of the code throughout this tutorial and see everything update in response to it!), and more :)","styles":{}}],"children":[]}],"loc":12},"14":{"type":"rich-text","contents":[{"id":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We will be building a compiler and type-checker for a pure, total, functional language with clojure-like syntax in a structured editor.","styles":{}}],"children":[]},{"id":"8d290f20-39ac-4477-96f5-2c268c672fe0","type":"table","props":{"textColor":"default","backgroundColor":"default"},"content":{"type":"tableContent","rows":[{"cells":[[{"type":"text","text":" Compiler","styles":{}}],[{"type":"text","text":"A program that takes in source code in one language and produces source code in another (possibly machine) language.","styles":{}}]]},{"cells":[[{"type":"text","text":"Type-checker","styles":{}}],[{"type":"text","text":"A program that analyzes source code to identify \"type errors\" (resulting from a mismatch between the type of a value and the expectations of the location where the value is being used). It may also produce information necessary to the compilation step.","styles":{}}]]},{"cells":[[{"type":"text","text":"Pure","styles":{}}],[{"type":"text","text":"No mutations, no side-effects, no accidental ","styles":{}},{"type":"text","text":"rm -rf /","styles":{"code":true}},{"type":"text","text":" :). Every function is a reliable mapping from inputs to outputs. This makes caching a much simpler problem, and is core to the behavior of the structured editor REPL environment.","styles":{}}]]},{"cells":[[{"type":"text","text":"Total","styles":{}}],[{"type":"text","text":"No exceptions (e.g. ","styles":{}},{"type":"text","text":"throw","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"catch","styles":{"code":true}},{"type":"text","text":"). For some intermediate implementations we will be relying on ","styles":{}},{"type":"text","text":"fatal","styles":{"code":true}},{"type":"text","text":" (akin to rust's \"panic\") to keep things simple, but we'll remove them later on as we get more disciplined about error handling.","styles":{}}]]},{"cells":[[{"type":"text","text":"Functional","styles":{}}],[{"type":"text","text":"Instead of a split between expressions (which evaluate to a value) and statements (which do not), there are only expressions.","styles":{}}]]},{"cells":[[{"type":"text","text":"Clojure-like syntax","styles":{}}],[{"type":"text","text":"a.k.a. \"lisp syntax\", closer to clojure than, say, racket. Why? It's dramatically easier to parse, and makes the mapping obvious between the syntax and the structure, which we'll take advantage of in the structured editor.","styles":{}}]]},{"cells":[[{"type":"text","text":"Structured Editor","styles":{}}],[{"type":"text","text":"An editor that works on the level of the ","styles":{}},{"type":"text","text":"structure","styles":{"italic":true}},{"type":"text","text":" of the language, instead of just \"a long sequence of text characters\". More on this in the next document.","styles":{}}]]}]},"children":[]},{"id":"4602c1c9-8775-4f01-9003-d005a97afe4b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Note that these definitions are highly subjective ðŸ˜‰.","styles":{}}],"children":[]}],"loc":14},"16":{"type":"rich-text","contents":[{"id":"42631239-3fc2-4f99-a4a5-8a886e89ad57","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"An Overview of the process:","styles":{}}],"children":[]}],"loc":16},"-1":{"type":"list","values":[0],"loc":-1}},"root":-1,"meta":{},"history":[],"clipboard":[],"hover":[],"regs":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":5,"idx":0},{"type":"ns","child":15,"idx":5},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":"2c0d7f62-2b69-46e9-abfd-023fc1d0a2cf"}]}],"cards":[{"path":[],"top":0}],"nsMap":{"0":{"id":0,"top":-1,"children":[1,5,7,9,17],"type":"normal"},"1":{"id":1,"top":0,"children":[],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3},"5":{"type":"normal","top":4,"children":[15],"id":5,"collapsed":false},"7":{"type":"normal","top":6,"children":[13],"id":7,"collapsed":false},"9":{"type":"normal","top":8,"children":[11],"id":9,"collapsed":false},"11":{"type":"normal","top":10,"children":[],"id":11},"13":{"type":"normal","top":12,"children":[],"id":13},"15":{"type":"normal","top":14,"children":[],"id":15},"17":{"type":"normal","top":16,"children":[3],"id":17,"collapsed":false}},"highlight":[]}