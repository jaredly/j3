{"map":{"0":{"type":"rich-text","contents":[{"id":"52022cf8-840d-4d65-9f10-a106de4d173b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Let's build a compiler!","styles":{}}],"children":[]}],"loc":0},"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add a basic \"do notation\" (via a syntax-only transform)  which will make tracking state in an immutable way much nicer, and we'll be able to do error tracking without resorting to a ","styles":{}},{"type":"text","text":"panic","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2},"-1":{"type":"list","values":[0],"loc":-1}},"root":-1,"meta":{},"history":[{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":1,"idx":0},{"type":"ns-top","idx":1},{"type":"rich-text","idx":0,"sel":"52022cf8-840d-4d65-9f10-a106de4d173b"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":1,"idx":0},{"type":"ns-top","idx":1},{"idx":0,"type":"subtext","at":0}]}],"prev":{"0":{"type":"blank","loc":0}},"meta":{},"metaPrev":{},"map":{"0":{"type":"rich-text","contents":[{"id":"52022cf8-840d-4d65-9f10-a106de4d173b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Let's build a compiler!","styles":{}}],"children":[]}],"loc":0}},"nsMap":{},"nsPrev":{},"id":0,"ts":1714757469.363,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"91b090fd-fe50-42b8-b9a3-d40413285da9"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":1,"idx":0},{"type":"ns-top","idx":1},{"type":"rich-text","idx":0,"sel":"52022cf8-840d-4d65-9f10-a106de4d173b"}]}],"prev":{"2":null},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"926e5b16-68a3-456d-9ce1-21a4b394a8e0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"What's cool about this compiler?","styles":{}}],"children":[]},{"id":"fbf7a78f-40e9-4760-93ae-7e41c76ab140","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"self-hosted! the compiler will be written in itself.","styles":{}}],"children":[]},{"id":"881eac0e-5a4c-4c01-b578-5a9aa6b976db","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"full type inference! We'll start with basic Hindley Milner, and work our way up to type classes, polymorphic row types, and more!","styles":{}}],"children":[]},{"id":"564a3cd9-289c-467c-9b58-710bccd805fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"pure + functional, with (eventually) algebraic effects!","styles":{}}],"children":[]},{"id":"badb4191-19ef-4c0c-943c-04b8d56c1aa5","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"structured editing! The editor for our language won't be \"plain text in a file\", but rather an editor that ","styles":{}},{"type":"text","text":"knows about the structure of the program","styles":{"italic":true}},{"type":"text","text":". Our compiler will hook into this to provide lots of nice things, including hover-for-type, inline error reporting, refactoring, and more!","styles":{}}],"children":[]},{"id":"fcb576ab-80b4-4475-93c9-69daa09dc674","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In fact, we'll be building a series of compilers, gradually getting more feature-rich, and correspondingly more fun to use.","styles":{}}],"children":[]},{"id":"94261d0c-1cea-4a0e-a452-808e082b9f28","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Our first compiler will be written in JavaScript, to allow us to \"bootstrap\" the self-hosting process. This compiler will be as simple as is reasonable while also giving us a language that's nice to use. This will consist of a parser (which will convert the \"concrete syntax tree\" of the structured editor into the \"Abstract Syntax Tree\" of our language) and a \"tree-walking interpreter\", which will traverse the AST and produce the resulting value. We'll also implement some basic static analysis, just enough to allow the editor or order our terms in dependency order.","styles":{}}],"children":[]},{"id":"0ad80d0e-1284-4193-9b4b-6d58c809f8dc","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Next we'll use the language L1 to produce a code generator, which will take our AST and produce JavaScript. At this stage we'll still be using the ","styles":{}},{"type":"text","text":"parser","styles":{"italic":true}},{"type":"text","text":" from our bootstrapping stage, but we'll replace the tree-walking interpreter, allowing us to produce JavaScript that doesn't require a hand-written interpreter.","styles":{}}],"children":[]},{"id":"cf132f00-e345-487f-b2ca-0f76026ddb2e","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"After that, we'll self-host the parser + static analysis, rewriting the bootstrap JavaScript implementation in our language L1.","styles":{}}],"children":[]},{"id":"7afc5384-e540-4f8f-8f82-57b77191d290","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"With parsing and code-generation, are we done? No! Now we need a type checker! This is where it really gets fun, because other tutorials tend to stick to parsing + code generation, and if you want to do type inference you're stuck reading a ton of academic papers ðŸ˜…. Well, I've done that reading for you, and we'll start with a very basic implementation of \"Algorithm W\" (the primary algorithm of Hindley Milner type inference).","styles":{}}],"children":[]},{"id":"738cf264-3dcd-4ac4-823c-48778f3ef051","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have Algorithm W working, we'll need to extend it just a bit to support all of the language features of L1 (specifically: custom data types & pattern matching).","styles":{}}],"children":[]},{"id":"91b090fd-fe50-42b8-b9a3-d40413285da9","type":"numberedListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Now that we have self-hosted type inference, let's make our language even nicer to use! We'll add a basic \"do notation\" (via a syntax-only transform)  which will make tracking state in an immutable way much nicer, and we'll be able to do error tracking without resorting to a ","styles":{}},{"type":"text","text":"panic","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"d2288f5a-36af-493a-a300-d41922ee5f12","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And that completes L1! Up to this point, everything we've written would be parseable & runnable by our original bootstrap implementation. Going forward, we'll have fancier language features like Type Classes and Algebraic Effects, which require information from the Type Inference step in order to produce the compiled output. ","styles":{}}],"children":[]},{"id":"c1ac748b-e773-4371-8a81-cbe83300cb19","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[],"children":[]}],"loc":2}},"nsMap":{"0":{"id":0,"top":-1,"children":[1,3],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3}},"nsPrev":{"0":{"id":0,"top":-1,"children":[1],"type":"normal"},"3":null},"id":1,"ts":1714757516.081,"libraryRoot":""}],"clipboard":[],"hover":[],"regs":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":3,"idx":0},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"91b090fd-fe50-42b8-b9a3-d40413285da9"}]}],"cards":[{"path":[],"top":0}],"nsMap":{"0":{"id":0,"top":-1,"children":[1,3],"type":"normal"},"1":{"id":1,"top":0,"children":[],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3}},"highlight":[]}