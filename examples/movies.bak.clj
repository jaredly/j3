; This is fully importable
(deftype Result (tfn [ok err] [('Ok ok) ('Err err)]))
(deftype httpResult (Result string ['Timeout 'Offline ('Other string)]))
(deftype GetUrl ('http/get string httpResult))
(deftype Log ('Log string ()))
(deftype Env/get ('env/get string (Result string ['Missing ('OSError string)])))
(defn return<X> [x:X] ('Return x))
(defn log [text:string] (! ('Log text return<()>)))
(defn tryit [text:string] (!? ('Help () return<(Result int string)>)))
(defn get-url [url:string] (! ('http/get url return<httpResult>)))
(def require (tfn [ok err] (fn [value:(Result ok err)] (switch value ('Ok ok) ('Return ok) ('Err err) ('Failure err ())))))
(def mapErr (tfn [ok err err2] (fn [value:(Result ok err) map:(fn [err] err2)] (switch value ('Err err) ('Err (map err)) x x))))
(deftype Movie {title string year int starring (array string)})
(def api-get ('env/get "API_KEY" (fn [x:(Result string ['Missing ('OSError string)])] ('Return x))))
(defn get-api-key [] (switch (! api-get) ('Err 'Missing) ('Err 'ApiKeyMissing) x x))
(def fail (tfn [Err:[..]] (fn [err:Err] ('Failure err ()))))
(defn parseInt [text:string]:(Result int ('NotAnInt string)) (switch (parse text) ('Some int) ('Ok int) 'None ('Err ('NotAnInt text))))
(def pure (tfn [x] (fn [value:x] ('Return value))))
(defn lineError<T> [idx:uint line:string] (fn [x:T] ('LineError idx line x)))
(defn movieFromLine [line:string idx:uint] (switch (split line "!") [title year starring] {title title year (!? (-> year parseInt (mapErr (lineError<('NotAnInt string)> idx line)) pure)) starring (split starring ",")} _ (! ('Failure ('LineError idx line 'InvalidLine) ()))))
(defnrec mapTask<T Effects:[..] R> [values:(array T) fnz:(fn [T uint] (@task Effects R)) at:uint]:(@task Effects (array R)) (switch values [one ..rest] (let [res (! (fnz one at)) coll (! (@recur<T Effects R> rest fnz (+ at 1u)))] [res ..coll]) _ []))
(defn getMovies [url:string] (let [response (!? ('GetUrl url (fn [x:httpResult] ('Return x)))) lines (-> response trim (split "\n"))] (! (mapTask<string [('Failure ('LineError uint string ['InvalidLine ('NotAnInt string)]))] Movie> lines movieFromLine 0u))) )
(defn writeOutput [movies:(array Movie)]:(@task ('fs/write-file {path string contents string} bool) bool) ('fs/write-file {path "output.json" contents (encode movies)} pure<bool>))
(defn task/to-result<Effects:[..] Errors:[..] Value> [task-top:(@task [Effects ('Failure Errors)] Value)]:(@task Effects (Result Value Errors)) ((fnrec [task:(@task [Effects ('Failure Errors)] Value)]:(@task Effects (Result Value Errors)) (switch task ('Failure error) ('Return ('Err error)) ('Return value) ('Return ('Ok value)) otherwise (withHandler<Effects Value ('Failure Errors) (Result Value Errors)> otherwise @recur)) ) task-top))
(defn task [] (let [apiKey (!? (get-api-key)) movies (! (getMovies "the-url${apiKey}"))] (! (writeOutput movies))))
(defn main [] (switch (! (to-result<[('GetUrl string httpResult) Env/get ('fs/write-file {path string contents string} bool)] ['Offline 'ApiKeyMissing ('OSError string) 'Timeout ('Other string) ('LineError uint string ['InvalidLine ('NotAnInt string)])] bool> (task))) ('Ok _) (! log "Success! Wrote to output.json") ('Err 'ApiKeyMissing) (! log "You need env API_KEY") ('Err ('LineError idx line err)) (! log "Error on line ${(debug/toString idx)}:\n${line}\n${(debug/toString err)}") ('Err 'http) (! log "Http error") ('Err 'fs) (! log "Unable to write to disk") ('Err _) (! log "Some other error, sorry")))
(defn main [] (switch (! (to-result (task))) ('Ok _) (! log "Success! Wrote to output.json") ('Err 'ApiKeyMissing) (! log "You need env API_KEY") ('Err ('LineError idx line err)) (! log "Error on line ${(debug/toString idx)}:\n${line}\n${(debug/toString err)}") ('Err 'http) (! log "Http error") ('Err 'fs) (! log "Unable to write to disk") ('Err _) (! log "Some other error, sorry")))